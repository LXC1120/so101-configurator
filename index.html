<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>èˆµæœºé…ç½®å·¥å…·ï¼ˆWeb Serialï¼‰</title>
  <style>
    :root{color-scheme:light dark}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",sans-serif;max-width:1020px;margin:0 auto;padding:18px;line-height:1.45}
    h1{font-size:20px;margin:0 0 10px}
    h2{font-size:16px;margin:0 0 10px}
    .card{border:1px solid rgba(127,127,127,.25);border-radius:14px;padding:14px;margin:12px 0;box-shadow:0 2px 10px rgba(0,0,0,.05)}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    label{display:flex;gap:8px;align-items:center}
    input,select,button{font:inherit}
    input,select{padding:8px 10px;border-radius:10px;border:1px solid rgba(127,127,127,.35)}
    input{width:110px}
    button{padding:9px 12px;border-radius:12px;border:1px solid rgba(127,127,127,.35);cursor:pointer}
    button:disabled{opacity:.45;cursor:not-allowed}
    .small{font-size:12px;opacity:.85}
    .pill{display:inline-block;padding:2px 10px;border:1px solid rgba(127,127,127,.35);border-radius:999px}
    .ok{color:#0a7a2f}
    .warn{color:#b45309}
    .bad{color:#b91c1c}
    pre{background:rgba(0,0,0,.85);color:#e8eefc;padding:12px;border-radius:14px;overflow:auto;max-height:340px}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width:980px){.grid{grid-template-columns:1fr 1fr}}
    table{border-collapse:collapse;width:100%}
    th,td{border-bottom:1px solid rgba(127,127,127,.22);padding:6px 8px;text-align:left;font-size:13px;vertical-align:middle}
    th{opacity:.9}
    .mini{width:80px}
  </style>
</head>
<body>
  <h1>èˆµæœºé…ç½®å·¥å…·ï¼ˆWeb Serial / æ¡Œé¢ Chromeï¼‰</h1>
  <div class="small">
    <span class="pill" id="statusPill">æœªè¿æ¥</span>
    <span class="pill">å¤–æ¥ç”µæºï½œTX/RX äº¤å‰ï½œGND å…±åœ°</span>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <button id="btnConnect">è¿æ¥ä¸²å£</button>
        <button id="btnDisconnect" disabled>æ–­å¼€</button>
      </div>
      <label>æ³¢ç‰¹ç‡ <input id="baud" inputmode="numeric" value="1000000"/></label>
    </div>
    <div class="row small" style="margin-top:10px;justify-content:space-between">
      <span class="warn">Web Serial ä»…åœ¨ HTTPSï¼ˆæˆ– http://localhostï¼‰å¯ç”¨ï¼›è¯·ä½¿ç”¨æ¡Œé¢ Chrome/Edgeã€‚</span>
      <label style="gap:10px"><input id="safeOneServo" type="checkbox" checked/>å†™æ“ä½œå‰æé†’â€œä¸€æ¬¡åªæ¥1ä¸ªèˆµæœºâ€</label>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>æµæ°´çº¿é…ç½®ï¼ˆè‡ªåŠ¨ç›‘æ§æ’æ‹”ï¼‰</h2>
      <div class="row">
        <label>èµ·å§‹ID <input id="pipeStart" inputmode="numeric" value="1" /></label>
        <label>ç»“æŸID <input id="pipeEnd" inputmode="numeric" value="6" /></label>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btnPipeStart" disabled>å¼€å§‹æµæ°´çº¿</button>
        <button id="btnPipeStop" disabled>ä¸­æ–­</button>
        <span class="pill" id="pipeState">æœªè¿è¡Œ</span>
      </div>
      <p class="small">
        æµæ°´çº¿é‡‡ç”¨å¹¿æ’­æ¢æµ‹æ’å…¥ï¼ˆPING 0xFEï¼‰ï¼Œè¯·ç¡®ä¿ä»»æ„æ—¶åˆ»æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºã€‚
      </p>
    </div>

    <div class="card">
      <h2>æ‰«æä¸å®æ—¶ä½ç½®</h2>
      <div class="row">
        <label>æ‰«æèµ·å§‹ <input id="scanStart" inputmode="numeric" value="1"/></label>
        <label>æ‰«æç»“æŸ <input id="scanEnd" inputmode="numeric" value="20"/></label>
        <button id="btnScanOnce" disabled>æ‰«æä¸€æ¬¡</button>
        <span class="pill" id="scanState">æœªæ‰«æ</span>
      </div>
      <div class="row" style="margin-top:10px">
        <label style="gap:10px"><input id="posEnable" type="checkbox" disabled checked/>è‡ªåŠ¨åˆ·æ–°ä½ç½®</label>
        <label>åˆ·æ–°ms <input id="posPeriod" class="mini" inputmode="numeric" value="50"/></label>
        <span class="pill" id="posState">æœªè¿è¡Œ</span>
      </div>
      <p class="small">
        ä½ç½®è¯»å–åªå– 0x38 çš„ 2 å­—èŠ‚ï¼ˆæ¯”è¯»å– 8 å­—èŠ‚æ›´çœå¸¦å®½ï¼‰ã€‚è‹¥è®¾å¤‡æ•°é‡å¾ˆå¤šï¼Œè¯·æŠŠåˆ·æ–° ms è°ƒå¤§ã€‚
      </p>
    </div>
  </div>

  <div class="card">
    <h2>åœ¨çº¿èˆµæœºè¡¨ï¼ˆæ¯è¡Œå«æ“ä½œï¼‰</h2>
    <table>
      <thead>
        <tr>
          <th>ID</th><th>åœ¨çº¿</th><th>ä½ç½®(0x38)</th><th>æ›´æ–°æ—¶é—´</th>
          <th>æ”¹ID</th><th>ä¸­å€¼</th><th>RESET</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
    <p class="small">
      â€œæ”¹IDâ€è¿™é‡Œç”¨çš„æ˜¯<strong>æŒ‰ç›®æ ‡IDå®šå‘å†™</strong>ï¼ˆä¸ä¼šåƒå¹¿æ’­é‚£æ ·å½±å“å…¶å®ƒèˆµæœºï¼‰ã€‚æµæ°´çº¿ä»ä¿æŒä½ çš„è„šæœ¬å¹¿æ’­æµç¨‹ã€‚
    </p>
  </div>

  <div class="card">
    <h2>æ—¥å¿—</h2>
    <pre id="log"></pre>
    <div class="row small" style="justify-content:space-between;margin-top:10px">
      <span>æç¤ºï¼šè¿æ¥æ—¶ä¼šå¼¹çª—é€‰æ‹©ä¸²å£è®¾å¤‡ï¼Œè¿™æ˜¯æ­£å¸¸æƒé™æœºåˆ¶ã€‚</span>
      <button id="btnClearLog">æ¸…ç©ºæ—¥å¿—</button>
    </div>
  </div>

<script>
(() => {
  // ====== å¸¸é‡ï¼ˆä¸ä½ è„šæœ¬ä¸€è‡´ï¼‰======
  const BROADCAST_ID = 0xFE;
  const ADDR_ID     = 0x05;
  const ADDR_LOCK   = 0x37;
  const ADDR_TORQUE = 0x28; // 40

  // ä¸²å£çŠ¶æ€
  let port=null, writer=null, reader=null, readLoopRunning=false;
  let rxBuf=[];

  // åœ¨çº¿è®¾å¤‡è¡¨ï¼šid -> {online, pos, ts}
  const devices = new Map();

  // UI
  const logEl = document.getElementById('log');
  const statusPill = document.getElementById('statusPill');
  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const baudEl = document.getElementById('baud');
  const safeOneServoEl = document.getElementById('safeOneServo');

  const pipeStartEl = document.getElementById('pipeStart');
  const pipeEndEl = document.getElementById('pipeEnd');
  const btnPipeStart = document.getElementById('btnPipeStart');
  const btnPipeStop = document.getElementById('btnPipeStop');
  const pipeStateEl = document.getElementById('pipeState');

  const scanStartEl = document.getElementById('scanStart');
  const scanEndEl = document.getElementById('scanEnd');
  const btnScanOnce = document.getElementById('btnScanOnce');
  const scanStateEl = document.getElementById('scanState');

  const posEnableEl = document.getElementById('posEnable');
  const posPeriodEl = document.getElementById('posPeriod');
  const posStateEl = document.getElementById('posState');

  const tbody = document.getElementById('tbody');
  const btnClearLog = document.getElementById('btnClearLog');

  function setStatus(text, kind="") {
    statusPill.textContent = text;
    statusPill.className = "pill " + kind;
  }
  function log(msg) {
    const t = new Date().toLocaleTimeString();
    logEl.textContent += `[${t}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // ====== åè®®ï¼šæ ¡éªŒä¸ç»„åŒ… ======
  function calcChecksum(dataBytes) {
    let sum=0;
    for (const b of dataBytes) sum += (b & 0xFF);
    return (~sum) & 0xFF;
  }
  function buildPacket(dataBytes) {
    const chk = calcChecksum(dataBytes);
    return new Uint8Array([0xFF, 0xFF, ...dataBytes, chk]);
  }
  async function ensureWriter(){
    if (!port) throw new Error("æœªè¿æ¥ä¸²å£");
    if (!writer) writer = port.writable.getWriter();
  }
  async function writeRaw(u8){
    await ensureWriter();
    await writer.write(u8);
  }

  // ====== è¯»å–ï¼šç¼“å­˜æ”¶åˆ°çš„å­—èŠ‚ ======
  async function startReadLoop(){
    reader = port.readable.getReader();
    readLoopRunning = true;
    rxBuf = [];
    (async () => {
      try{
        while (readLoopRunning){
          const {value, done} = await reader.read();
          if (done) break;
          if (value && value.length){
            for (const b of value) rxBuf.push(b);
            if (rxBuf.length > 8192) rxBuf = rxBuf.slice(-4096);
          }
        }
      } catch(e){
        log(`è¯»å–å¼‚å¸¸: ${e.message || e}`);
      }
    })();
  }
  async function stopReadLoop(){
    readLoopRunning = false;
    if (reader){
      try{ await reader.cancel(); } catch{}
      try{ reader.releaseLock(); } catch{}
      reader = null;
    }
    rxBuf=[];
  }

  // ====== å¸§è§£æï¼šä» rxBuf ä¸­æŠ½å–ä¸€å¸§ ======
  function tryPopFrame(){
    for (let i=0; i+6<=rxBuf.length; i++){
      if (rxBuf[i]!==0xFF || rxBuf[i+1]!==0xFF) continue;
      const len = rxBuf[i+3];
      const total = 2 + 1 + 1 + len; // FF FF + ID + LEN + (len bytes: ERROR..CHK)
      if (i+total > rxBuf.length) return null;
      const frame = rxBuf.slice(i, i+total);
      rxBuf = rxBuf.slice(i+total);
      return frame;
    }
    if (rxBuf.length > 4096) rxBuf = rxBuf.slice(-1024);
    return null;
  }

  // ====== åŸºæœ¬æŒ‡ä»¤ ======
  async function ping(id, timeoutMs=90){
    const data = [id & 0xFF, 0x02, 0x01];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);
    const start = performance.now();
    while (performance.now() - start < timeoutMs){
      const fr = tryPopFrame();
      if (fr) return true;
      await sleep(3);
    }
    return false;
  }

  async function writeReg(id, address, value){
    const data = [id & 0xFF, 0x04, 0x03, address & 0xFF, value & 0xFF];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);
    await sleep(50);
  }

  async function readReg(id, address, size, timeoutMs=35){
    const data = [id & 0xFF, 0x04, 0x02, address & 0xFF, size & 0xFF];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);

    const start = performance.now();
    while (performance.now() - start < timeoutMs){
      const fr = tryPopFrame();
      if (!fr){ await sleep(1); continue; }
      const err = fr[4];
      if (err !== 0) return null;
      const paramsLen = fr[3] - 2;
      return fr.slice(5, 5 + paramsLen);
    }
    return null;
  }

  // ====== å•æ¬¡æ”¹å·ï¼ˆå¹¿æ’­ç‰ˆï¼šæµæ°´çº¿ä¿æŒä½ çš„è„šæœ¬é¡ºåºï¼‰======
  async function changeIdBroadcastLikeScript(newId){
    newId = Number(newId);
    if (!(newId>=1 && newId<=253)) throw new Error("ID èŒƒå›´ 1~253");
    await writeReg(BROADCAST_ID, ADDR_LOCK, 0);
    await writeReg(BROADCAST_ID, ADDR_TORQUE, 0);
    await writeReg(BROADCAST_ID, ADDR_ID, newId);
    await sleep(150);
    await writeReg(newId, ADDR_LOCK, 1);

    // éªŒè¯ï¼ˆè¿ç»­ä¸¤æ¬¡æˆåŠŸæ›´ç¨³ï¼‰
    let ok1 = await ping(newId, 160);
    if (!ok1){ await sleep(250); ok1 = await ping(newId, 160); }
    if (!ok1) throw new Error("éªŒè¯å¤±è´¥");
  }

  // ====== å•ç‹¬æ”¹å·ï¼ˆå®šå‘ç‰ˆï¼šç”¨äºè¡¨æ ¼æ¯è¡ŒæŒ‰é’®ï¼Œé¿å…è¯¯ä¼¤å…¶å®ƒèˆµæœºï¼‰======
  async function changeIdTargeted(oldId, newId){
    oldId = Number(oldId); newId = Number(newId);
    if (!(oldId>=0 && oldId<=253)) throw new Error("æ—§IDä¸åˆæ³•");
    if (!(newId>=1 && newId<=253)) throw new Error("æ–°IDéœ€åœ¨ 1~253");
    // å®šå‘è§£é”/å…³æ‰­åŠ›/å†™ID/ä¸Šé”
    await writeReg(oldId, ADDR_LOCK, 0);
    await writeReg(oldId, ADDR_TORQUE, 0);
    await writeReg(oldId, ADDR_ID, newId);
    await sleep(150);
    await writeReg(newId, ADDR_LOCK, 1);

    // éªŒè¯
    let ok = await ping(newId, 160);
    if (!ok){ await sleep(250); ok = await ping(newId, 160); }
    if (!ok) throw new Error("éªŒè¯å¤±è´¥");
  }

  // ====== åŠ¨ä½œï¼šå†™40=128 / RESET ======
  async function writeMiddleCalibrate(id){
    await writeReg(id, 0x28, 128);
    await sleep(30);
  }
  async function resetState(id){
    const data = [id & 0xFF, 0x02, 0x0A];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);
    await sleep(60);
  }

  // ====== æ¸²æŸ“è¡¨æ ¼ï¼ˆæ¯è¡ŒæŒ‰é’®ï¼‰======
  function renderTable(){
    const ids = Array.from(devices.keys()).sort((a,b)=>a-b);
    tbody.innerHTML = ids.map(id=>{
      const d = devices.get(id);
      const online = d.online ? "âœ…" : "";
      const pos = (d.pos ?? "");
      const ts = d.ts ? new Date(d.ts).toLocaleTimeString() : "";
      return `<tr data-id="${id}">
        <td>${id}</td>
        <td>${online}</td>
        <td>${pos}</td>
        <td>${ts}</td>
        <td>
          <input class="mini" inputmode="numeric" placeholder="æ–°ID" data-newid="${id}"/>
          <button data-action="change" data-id="${id}" ${d.online ? "" : "disabled"}>æ”¹ID</button>
        </td>
        <td><button data-action="mid" data-id="${id}" ${d.online ? "" : "disabled"}>å†™40=128</button></td>
        <td><button data-action="rst" data-id="${id}" ${d.online ? "" : "disabled"}>RESET</button></td>
      </tr>`;
    }).join("");
  }

  tbody.addEventListener("click", async (ev) => {
    const btn = ev.target.closest("button");
    if (!btn) return;
    const action = btn.getAttribute("data-action");
    const id = Number(btn.getAttribute("data-id"));
    if (!port) return;

    try{
      // â€œåªæ¥1ä¸ªâ€æç¤ºï¼šå¯¹å†™æ“ä½œå‰æé†’ï¼ˆå¯å…³ï¼‰
      if (safeOneServoEl.checked) {
        const ok = confirm("å†™æ“ä½œå‰ç¡®è®¤ï¼šå½“å‰æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºï¼Ÿ\nï¼ˆæµæ°´çº¿æ¨¡å¼å¼ºä¾èµ–åªæ¥1ä¸ªï¼›å•ç‹¬æ”¹IDè¿™é‡Œç”¨çš„æ˜¯å®šå‘å†™ï¼Œä¼šæ›´å®‰å…¨ï¼Œä½†ä»å»ºè®®åªæ¥1ä¸ªã€‚ï¼‰");
        if (!ok) return;
      }

      btn.disabled = true;

      if (action === "change"){
        const input = tbody.querySelector(`input[data-newid="${id}"]`);
        const newId = Number(input?.value);
        if (!Number.isFinite(newId)) throw new Error("è¯·è¾“å…¥æ–°ID");
        log(`æ”¹IDï¼ˆå®šå‘ï¼‰ï¼š${id} -> ${newId}`);
        await changeIdTargeted(id, newId);
        log("âœ… æ”¹IDæˆåŠŸï¼ˆå®šå‘ï¼‰");
        // æ‰«æè¡¨é‡Œæ›´æ–°ï¼šæŠŠæ—§idæ ‡ç¦»çº¿ï¼Œæ–°idåŠ å…¥
        if (!devices.has(newId)) devices.set(newId, {online:true});
        const old = devices.get(id); if (old) old.online = false;
        const nd = devices.get(newId); nd.online = true; nd.ts = Date.now();
        renderTable();
      } else if (action === "mid"){
        log(`å†™40=128ï¼šID=${id}`);
        await writeMiddleCalibrate(id);
        log("âœ… å†™å…¥å®Œæˆ");
      } else if (action === "rst"){
        log(`RESETï¼šID=${id}`);
        await resetState(id);
        log("âœ… å·²å‘é€ RESET");
      }
    } catch(e){
      log(`æ“ä½œå¤±è´¥: ${e.message || e}`);
    } finally {
      btn.disabled = false;
    }
  });

  // ====== æ‰«æï¼šæ‰«æä¸€æ¬¡åè‡ªåŠ¨åœæ­¢ ======
  async function scanOnce(){
    const start = Number(scanStartEl.value);
    const end = Number(scanEndEl.value);
    if (!Number.isFinite(start)||!Number.isFinite(end)||start<1||end>253||start>end){
      alert("æ‰«æèŒƒå›´ä¸åˆæ³•ï¼ˆ1~253 ä¸” èµ·å§‹<=ç»“æŸï¼‰");
      return;
    }
    scanStateEl.textContent = "æ‰«æä¸­...";
    for (let id=start; id<=end; id++){
      const ok = await ping(id, 40);
      if (!devices.has(id)) devices.set(id, {online:false});
      const d = devices.get(id);
      d.online = ok;
      if (ok) d.ts = Date.now();
    }
    scanStateEl.textContent = "æ‰«æå®Œæˆ";
    renderTable();

    // è‡ªåŠ¨å¼€å¯ä½ç½®åˆ·æ–°ï¼ˆå¦‚æœå‹¾é€‰ï¼‰
    if (posEnableEl.checked) ensurePosLoop();
  }

  // ====== å®æ—¶ä½ç½®ï¼šåªè¯» 0x38 ä¸¤å­—èŠ‚ ======
  let posLoopRunning=false;
  async function posLoop(){
    posLoopRunning = true;
    posStateEl.textContent = "è¿è¡Œä¸­";
    while (posLoopRunning && port){
      const period = Math.max(20, Number(posPeriodEl.value)||50);

      // åªåˆ·åœ¨çº¿çš„
      const ids = Array.from(devices.keys()).filter(id => devices.get(id).online);
      for (const id of ids){
        const params = await readReg(id, 0x38, 2, 25);
        if (!params || params.length < 2) continue;
        const pos = params[0] | (params[1]<<8);
        const d = devices.get(id);
        d.pos = pos;
        d.ts = Date.now();
      }
      renderTable();
      await sleep(period);
    }
    posStateEl.textContent = "å·²åœæ­¢";
  }

  function ensurePosLoop(){
    if (!posEnableEl.checked || !port) return;
    if (posLoopRunning) return;
    posLoop(); // fire and forget
  }
  function stopPosLoop(){
    posLoopRunning = false;
  }

  posEnableEl.addEventListener("change", () => {
    if (posEnableEl.checked) ensurePosLoop();
    else stopPosLoop();
  });

  // ====== æµæ°´çº¿ï¼šä¿®å¤â€œè·³è¿‡IDâ€â€”â€”å…³é”®ç‚¹ï¼šé¿å…å¹¶å‘ tick + æ’å…¥/æ‹”å‡ºåšå»æŠ– ======
  let pipeRunning=false;
  let pipeTarget=1, pipeStart=1, pipeEnd=6;
  let pipeState="IDLE"; // WAIT_INSERT | PROGRAMMING | WAIT_REMOVE
  let insertSeenCount=0;         // è¿ç»­çœ‹åˆ°æ’å…¥æ¬¡æ•°
  let removeLostSince=null;      // ç¦»çº¿èµ·å§‹
  let pipeBusy=false;

  async function pipeLoop(){
    while (pipeRunning && port){
      const stepDelay = 80;

      if (pipeBusy){ await sleep(stepDelay); continue; }
      pipeBusy = true;

      try{
        if (pipeState === "WAIT_INSERT"){
          const seen = await ping(BROADCAST_ID, 90);
          insertSeenCount = seen ? (insertSeenCount + 1) : 0;

          // è¿ç»­ N æ¬¡çœ‹åˆ°æ’å…¥æ‰è§¦å‘ï¼ˆé˜²æŠ–ï¼Œé¿å…å¶å‘å›åŒ…å¯¼è‡´è¯¯è§¦å‘ï¼‰
          if (insertSeenCount >= 3){
            pipeState = "PROGRAMMING";
            pipeStateEl.textContent = `æ£€æµ‹åˆ°æ’å…¥ï¼Œé…ç½® ID=${pipeTarget}...`;
            insertSeenCount = 0;
          } else {
            pipeStateEl.textContent = `ç­‰å¾…æ’å…¥ï¼ˆç›®æ ‡ ID=${pipeTarget}ï¼‰...`;
          }
        }
        else if (pipeState === "PROGRAMMING"){
          await changeIdBroadcastLikeScript(pipeTarget);
          log(`âœ… æµæ°´çº¿å†™å…¥æˆåŠŸï¼šID=${pipeTarget}`);
          pipeState = "WAIT_REMOVE";
          removeLostSince = null;
          pipeStateEl.textContent = `å·²å†™å…¥ ID=${pipeTarget}ï¼Œè¯·æ‹”æ‰èˆµæœº...`;
        }
        else if (pipeState === "WAIT_REMOVE"){
          // â€œæ‹”æ‰åˆ¤å®šâ€æ›´ç¨³ï¼šè¦æ±‚æ–°IDè¿ç»­ç¦»çº¿ >= 1s
          const online = await ping(pipeTarget, 90);
          if (online){
            removeLostSince = null;
          } else {
            if (removeLostSince == null) removeLostSince = performance.now();
            const lostMs = performance.now() - removeLostSince;
            if (lostMs >= 1000){
              if (pipeTarget >= pipeEnd){
                log(`ğŸ‰ æµæ°´çº¿å®Œæˆï¼š${pipeStart}~${pipeEnd}`);
                pipeStateEl.textContent = `å®Œæˆï¼š${pipeStart}~${pipeEnd}`;
                pipeRunning = false;
              } else {
                pipeTarget += 1;
                pipeState = "WAIT_INSERT";
                insertSeenCount = 0;
                removeLostSince = null;
                log(`è¯·æ’å…¥ä¸‹ä¸€åªèˆµæœºï¼Œç›®æ ‡ ID=${pipeTarget}`);
              }
            }
          }
        }
      } catch(e){
        log(`æµæ°´çº¿å¼‚å¸¸: ${e.message || e}`);
        pipeRunning = false;
        pipeStateEl.textContent = "å¼‚å¸¸åœæ­¢";
      } finally {
        pipeBusy = false;
      }

      await sleep(stepDelay);
    }

    // é€€å‡ºæ¸…ç†
    btnPipeStart.disabled = !port;
    btnPipeStop.disabled = true;
    if (!pipeStateEl.textContent.startsWith("å®Œæˆ") && pipeStateEl.textContent !== "å¼‚å¸¸åœæ­¢") {
      pipeStateEl.textContent = "æœªè¿è¡Œ";
    }
  }

  function startPipeline(){
    pipeStart = Number(pipeStartEl.value);
    pipeEnd = Number(pipeEndEl.value);
    if (!Number.isFinite(pipeStart) || !Number.isFinite(pipeEnd) || pipeStart<1 || pipeEnd>253 || pipeStart>pipeEnd){
      alert("æµæ°´çº¿èŒƒå›´ä¸åˆæ³•ï¼ˆ1~253 ä¸” èµ·å§‹<=ç»“æŸï¼‰");
      return;
    }
    if (safeOneServoEl.checked){
      const ok = confirm("æµæ°´çº¿æ¨¡å¼ä¼šä½¿ç”¨å¹¿æ’­æ¢æµ‹ä¸å¹¿æ’­å†™å…¥ã€‚\nè¯·ç¡®è®¤ï¼šä»»æ„æ—¶åˆ»æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºã€‚");
      if (!ok) return;
    }

    pipeRunning = true;
    pipeTarget = pipeStart;
    pipeState = "WAIT_INSERT";
    insertSeenCount = 0;
    removeLostSince = null;

    btnPipeStart.disabled = true;
    btnPipeStop.disabled = false;
    pipeStateEl.textContent = `ç­‰å¾…æ’å…¥ï¼ˆç›®æ ‡ ID=${pipeTarget}ï¼‰...`;
    log(`æµæ°´çº¿å¯åŠ¨ï¼šå°†é…ç½® ID=${pipeStart}~${pipeEnd}ã€‚è¯·æ’å…¥ç¬¬ä¸€åªèˆµæœº...`);
    pipeLoop(); // async loop
  }

  function stopPipeline(){
    pipeRunning = false;
    btnPipeStart.disabled = !port;
    btnPipeStop.disabled = true;
    pipeStateEl.textContent = "æœªè¿è¡Œ";
    log("æµæ°´çº¿å·²ä¸­æ–­");
  }

  // ====== è¿æ¥/æ–­å¼€ ======
  function setUiConnected(connected){
    btnConnect.disabled = connected;
    btnDisconnect.disabled = !connected;
    baudEl.disabled = connected;

    btnPipeStart.disabled = !connected;
    btnPipeStop.disabled = true;

    btnScanOnce.disabled = !connected;

    posEnableEl.disabled = !connected;
    posStateEl.textContent = connected ? (posEnableEl.checked ? "è¿è¡Œä¸­/å¾…åˆ·æ–°" : "æœªè¿è¡Œ") : "æœªè¿è¡Œ";

    scanStateEl.textContent = "æœªæ‰«æ";
    pipeStateEl.textContent = "æœªè¿è¡Œ";

    if (!connected) setStatus("æœªè¿æ¥");
    else setStatus("å·²è¿æ¥", "ok");
  }

  btnConnect.onclick = async () => {
    try{
      if (!("serial" in navigator)){
        alert("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Web Serialã€‚è¯·ä½¿ç”¨æ¡Œé¢ç‰ˆ Chrome/Edgeã€‚");
        return;
      }
      const baudRate = Number(baudEl.value || "1000000");
      if (!Number.isFinite(baudRate) || baudRate<=0){ alert("æ³¢ç‰¹ç‡ä¸åˆæ³•"); return; }

      port = await navigator.serial.requestPort();
      await port.open({ baudRate });
      await startReadLoop();

      setUiConnected(true);
      log(`å·²è¿æ¥ä¸²å£ï¼Œbaud=${baudRate}`);
      if (posEnableEl.checked) ensurePosLoop();
    } catch(e){
      log(`è¿æ¥å¤±è´¥: ${e.message || e}`);
      setUiConnected(false);
      port = null;
    }
  };

  btnDisconnect.onclick = async () => {
    try{
      stopPipeline();
      stopPosLoop();
      await stopReadLoop();
      if (writer){ try{ writer.releaseLock(); } catch{} writer=null; }
      if (port){ await port.close(); }
      port=null;
      setUiConnected(false);
      log("å·²æ–­å¼€ä¸²å£");
    } catch(e){
      log(`æ–­å¼€å¤±è´¥: ${e.message || e}`);
    }
  };

  // æŒ‰é’®ç»‘å®š
  btnScanOnce.onclick = () => scanOnce().catch(e=>log(`æ‰«æå¤±è´¥: ${e.message||e}`));
  btnPipeStart.onclick = () => startPipeline();
  btnPipeStop.onclick = () => stopPipeline();
  btnClearLog.onclick = () => { logEl.textContent = ""; };

  // åˆå§‹
  setUiConnected(false);
})();
</script>
</body>
</html>
