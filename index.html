<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>èˆµæœºé…ç½®å·¥å…·V7ï¼ˆWeb Serial / æ¡Œé¢ Chromeï¼‰</title>
  <style>
    :root{color-scheme:light dark}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",sans-serif;max-width:1040px;margin:0 auto;padding:18px;line-height:1.45}
    h1{font-size:20px;margin:0 0 10px}
    h2{font-size:16px;margin:0 0 10px}
    .card{border:1px solid rgba(127,127,127,.25);border-radius:14px;padding:14px;margin:12px 0;box-shadow:0 2px 10px rgba(0,0,0,.05)}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    label{display:flex;gap:8px;align-items:center}
    input,select,button{font:inherit}
    input,select{padding:8px 10px;border-radius:10px;border:1px solid rgba(127,127,127,.35)}
    input{width:110px}
    button{padding:9px 12px;border-radius:12px;border:1px solid rgba(127,127,127,.35);cursor:pointer}
    button:disabled{opacity:.45;cursor:not-allowed}
    .small{font-size:12px;opacity:.85}
    .pill{display:inline-block;padding:2px 10px;border:1px solid rgba(127,127,127,.35);border-radius:999px}
    .ok{color:#0a7a2f}
    .warn{color:#b45309}
    pre{background:rgba(0,0,0,.85);color:#e8eefc;padding:12px;border-radius:14px;overflow:auto;max-height:340px}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width:980px){.grid{grid-template-columns:1fr 1fr}}
    table{border-collapse:collapse;width:100%}
    th,td{border-bottom:1px solid rgba(127,127,127,.22);padding:6px 8px;text-align:left;font-size:13px;vertical-align:middle}
    th{opacity:.9}
    .mini{width:86px}
  </style>
</head>
<body>
  <h1>èˆµæœºé…ç½®å·¥å…·V7ï¼ˆWeb Serial / æ¡Œé¢ Chromeï¼‰</h1>
  <div class="small">
    <span class="pill" id="statusPill">æœªè¿æ¥</span>
    <span class="pill">å¤–æ¥ç”µæºï½œTX/RX äº¤å‰ï½œGND å…±åœ°</span>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <button id="btnConnect">è¿æ¥ä¸²å£</button>
        <button id="btnDisconnect" disabled>æ–­å¼€</button>
      </div>
      <label>æ³¢ç‰¹ç‡ <input id="baud" inputmode="numeric"/></label>
    </div>
    <div class="row small" style="margin-top:10px;justify-content:space-between">
      <span class="warn">Web Serial ä»…åœ¨ HTTPSï¼ˆæˆ– http://localhostï¼‰å¯ç”¨ï¼›è¯·ä½¿ç”¨æ¡Œé¢ Chrome/Edgeã€‚</span>
      <label style="gap:10px"><input id="safeOneServo" type="checkbox"/>å†™æ“ä½œå‰æé†’â€œä¸€æ¬¡åªæ¥1ä¸ªèˆµæœºâ€</label>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>æµæ°´çº¿é…ç½®ï¼ˆè‡ªåŠ¨ç›‘æ§æ’æ‹”ï¼‰</h2>
      <div class="row">
        <label>èµ·å§‹ID <input id="pipeStart" inputmode="numeric"/></label>
        <label>ç»“æŸID <input id="pipeEnd" inputmode="numeric"/></label>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btnPipeStart" disabled>å¼€å§‹æµæ°´çº¿</button>
        <button id="btnPipeStop" disabled>ä¸­æ–­</button>
        <span class="pill" id="pipeState">æœªè¿è¡Œ</span>
      </div>
      <p class="small">æµæ°´çº¿ç”¨å¹¿æ’­æ¢æµ‹æ’å…¥ï¼ˆPING 0xFEï¼‰+ å¹¿æ’­å†™å…¥ï¼Œè¯·ç¡®ä¿ä»»æ„æ—¶åˆ»æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºã€‚</p>
    </div>

    <div class="card">
      <h2>æ‰«æä¸å®æ—¶ä½ç½®</h2>
      <div class="row">
        <label>æ‰«æèµ·å§‹ <input id="scanStart" inputmode="numeric"/></label>
        <label>æ‰«æç»“æŸ <input id="scanEnd" inputmode="numeric"/></label>
        <button id="btnScanOnce" disabled>æ‰«æä¸€æ¬¡</button>
        <span class="pill" id="scanState">æœªæ‰«æ</span>
      </div>
      <div class="row" style="margin-top:10px">
        <label style="gap:10px"><input id="posEnable" type="checkbox" disabled/>è‡ªåŠ¨åˆ·æ–°ä½ç½®/åœ¨çº¿çŠ¶æ€</label>
        <label>åˆ·æ–°ms <input id="posPeriod" class="mini" inputmode="numeric"/></label>
        <span class="pill" id="posState">æœªè¿è¡Œ</span>
      </div>
      <p class="small">
        æ‰«æåªæŠŠ<strong>åœ¨çº¿èˆµæœº</strong>åŠ å…¥è¡¨æ ¼ï¼›ä¹‹åä¸å†è‡ªåŠ¨å¢åˆ è¡Œã€‚å®æ—¶åˆ·æ–°ä¼šæ›´æ–°åœ¨çº¿çŠ¶æ€ï¼šè¿ç»­è¯»ä¸åˆ°ä½ç½®ä¼šæ ‡è®°ä¸ºç¦»çº¿ã€‚
      </p>
    </div>
  </div>

  <div class="card">
    <h2>åœ¨çº¿èˆµæœºè¡¨ï¼ˆæ¯è¡Œå«æ“ä½œï¼‰</h2>
    <table>
      <thead>
        <tr>
          <th>ID</th><th>åœ¨çº¿</th><th>ä½ç½®(0x38)</th><th>æ›´æ–°æ—¶é—´</th>
          <th>æ”¹ID</th><th>ä¸­å€¼</th><th>RESET</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
    <p class="small">åˆ·æ–°é¡µé¢åä¼šä»æœ¬åœ°å­˜å‚¨æ¢å¤è¾“å…¥ä¸è¡¨æ ¼ï¼ˆä½†ä¸²å£è¿æ¥éœ€è¦é‡æ–°ç‚¹â€œè¿æ¥ä¸²å£â€æˆæƒï¼‰ã€‚</p>
  </div>

  <div class="card">
    <h2>æ—¥å¿—</h2>
    <pre id="log"></pre>
    <div class="row small" style="justify-content:space-between;margin-top:10px">
      <span>æç¤ºï¼šè¿æ¥æ—¶ä¼šå¼¹çª—é€‰æ‹©ä¸²å£è®¾å¤‡ï¼Œè¿™æ˜¯æ­£å¸¸æƒé™æœºåˆ¶ã€‚</span>
      <button id="btnClearLog">æ¸…ç©ºæ—¥å¿—</button>
    </div>
  </div>

<script>
(() => {
  const BROADCAST_ID = 0xFE;
  const ADDR_ID     = 0x05;
  const ADDR_LOCK   = 0x37;
  const ADDR_TORQUE = 0x28; // 40

  const LS_KEY = "servo_tool_state_v7";
  function loadState(){
    try{ return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }catch{ return {}; }
  }
  function saveState(partial){
    const cur = loadState();
    const next = Object.assign({}, cur, partial);
    localStorage.setItem(LS_KEY, JSON.stringify(next));
  }

  let port=null, writer=null, reader=null, readLoopRunning=false;
  let rxBuf=[];

  // ä¸²å£äº’æ–¥é”ï¼šé¿å…å¹¶å‘ä¸²å°
  let opChain = Promise.resolve();
  function withLock(fn){
    const next = opChain.then(fn, fn);
    opChain = next.catch(()=>{});
    return next;
  }

  // è®¾å¤‡è¡¨ï¼šid -> {online, pos, ts, failCount, row}
  const devices = new Map();

  // UI
  const logEl = document.getElementById('log');
  const statusPill = document.getElementById('statusPill');
  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const baudEl = document.getElementById('baud');
  const safeOneServoEl = document.getElementById('safeOneServo');

  const pipeStartEl = document.getElementById('pipeStart');
  const pipeEndEl = document.getElementById('pipeEnd');
  const btnPipeStart = document.getElementById('btnPipeStart');
  const btnPipeStop = document.getElementById('btnPipeStop');
  const pipeStateEl = document.getElementById('pipeState');

  const scanStartEl = document.getElementById('scanStart');
  const scanEndEl = document.getElementById('scanEnd');
  const btnScanOnce = document.getElementById('btnScanOnce');
  const scanStateEl = document.getElementById('scanState');

  const posEnableEl = document.getElementById('posEnable');
  const posPeriodEl = document.getElementById('posPeriod');
  const posStateEl = document.getElementById('posState');

  const tbody = document.getElementById('tbody');
  const btnClearLog = document.getElementById('btnClearLog');

  function setStatus(text, kind="") {
    statusPill.textContent = text;
    statusPill.className = "pill " + kind;
  }
  function log(msg) {
    const t = new Date().toLocaleTimeString();
    logEl.textContent += `[${t}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // æ¢å¤è¾“å…¥ & è¡¨æ ¼
  function restoreFromLocalStorage(){
    const s = loadState();
    baudEl.value = String(s.baud ?? 1000000);
    safeOneServoEl.checked = !!(s.safeOneServo ?? true);
    pipeStartEl.value = String(s.pipeStart ?? 1);
    pipeEndEl.value = String(s.pipeEnd ?? 6);
    scanStartEl.value = String(s.scanStart ?? 1);
    scanEndEl.value = String(s.scanEnd ?? 20);
    posEnableEl.checked = !!(s.posEnable ?? true);
    posPeriodEl.value = String(s.posPeriod ?? 50);

    const ids = Array.isArray(s.ids) ? s.ids : [];
    for (const id of ids){
      if (!Number.isFinite(id)) continue;
      ensureDevice(id);
      const rowState = (s.rowState && s.rowState[String(id)]) ? s.rowState[String(id)] : null;
      if (rowState && typeof rowState.newIdInput === "string"){
        devices.get(id).row.input.value = rowState.newIdInput;
      }
      updateRow(id);
    }
  }
  function persistInputs(){
    saveState({
      baud: Number(baudEl.value||1000000),
      safeOneServo: safeOneServoEl.checked,
      pipeStart: Number(pipeStartEl.value||1),
      pipeEnd: Number(pipeEndEl.value||6),
      scanStart: Number(scanStartEl.value||1),
      scanEnd: Number(scanEndEl.value||20),
      posEnable: posEnableEl.checked,
      posPeriod: Number(posPeriodEl.value||50),
    });
  }
  function persistTableState(){
    const ids = Array.from(devices.keys()).sort((a,b)=>a-b);
    const rowState = {};
    for (const id of ids){
      const d = devices.get(id);
      if (d.row) rowState[String(id)] = { newIdInput: d.row.input.value || "" };
    }
    saveState({ ids, rowState });
  }
  [baudEl, safeOneServoEl, pipeStartEl, pipeEndEl, scanStartEl, scanEndEl, posEnableEl, posPeriodEl].forEach(el=>{
    el.addEventListener("change", () => persistInputs());
  });

  // åè®®
  function calcChecksum(dataBytes) {
    let sum=0;
    for (const b of dataBytes) sum += (b & 0xFF);
    return (~sum) & 0xFF;
  }
  function buildPacket(dataBytes) {
    const chk = calcChecksum(dataBytes);
    return new Uint8Array([0xFF, 0xFF, ...dataBytes, chk]);
  }
  function verifyFrameChecksum(frame){
    if (!frame || frame.length < 6) return false;
    const len = frame[3];
    const total = 2 + 1 + 1 + len;
    if (frame.length !== total) return false;
    const dataBytes = frame.slice(2, frame.length - 1);
    const chk = calcChecksum(dataBytes);
    return chk === frame[frame.length - 1];
  }

  async function ensureWriter(){
    if (!port) throw new Error("æœªè¿æ¥ä¸²å£");
    if (!writer) writer = port.writable.getWriter();
  }
  async function writeRaw(u8){
    await ensureWriter();
    await writer.write(u8);
  }

  async function startReadLoop(){
    reader = port.readable.getReader();
    readLoopRunning = true;
    rxBuf = [];
    (async () => {
      try{
        while (readLoopRunning){
          const {value, done} = await reader.read();
          if (done) break;
          if (value && value.length){
            for (const b of value) rxBuf.push(b);
            if (rxBuf.length > 8192) rxBuf = rxBuf.slice(-4096);
          }
        }
      } catch(e){
        log(`è¯»å–å¼‚å¸¸: ${e.message || e}`);
      }
    })();
  }
  async function stopReadLoop(){
    readLoopRunning = false;
    if (reader){
      try{ await reader.cancel(); }catch{}
      try{ reader.releaseLock(); }catch{}
      reader = null;
    }
    rxBuf=[];
  }

  function tryPopFrame(){
    for (let i=0; i+6<=rxBuf.length; i++){
      if (rxBuf[i]!==0xFF || rxBuf[i+1]!==0xFF) continue;
      const len = rxBuf[i+3];
      const total = 2 + 1 + 1 + len;
      if (i+total > rxBuf.length) return null;
      const frame = rxBuf.slice(i, i+total);
      rxBuf = rxBuf.slice(i+total);
      if (!verifyFrameChecksum(frame)) continue;
      return frame;
    }
    if (rxBuf.length > 4096) rxBuf = rxBuf.slice(-1024);
    return null;
  }

  async function waitFrame(expectedId, timeoutMs){
    const start = performance.now();
    while (performance.now() - start < timeoutMs){
      const fr = tryPopFrame();
      if (!fr){ await sleep(1); continue; }
      const id = fr[2];
      if (expectedId == null || id === expectedId) return fr;
    }
    return null;
  }

  async function ping(id, timeoutMs=90){
    return withLock(async () => {
      const pkt = buildPacket([id & 0xFF, 0x02, 0x01]);
      rxBuf = [];
      await writeRaw(pkt);
      const fr = await waitFrame(id, timeoutMs);
      return !!fr;
    });
  }
  async function pingBroadcastAny(timeoutMs=90){
    return withLock(async () => {
      const pkt = buildPacket([BROADCAST_ID, 0x02, 0x01]);
      rxBuf = [];
      await writeRaw(pkt);
      const fr = await waitFrame(null, timeoutMs);
      return !!fr;
    });
  }
  async function writeReg(id, address, value){
    return withLock(async () => {
      const pkt = buildPacket([id & 0xFF, 0x04, 0x03, address & 0xFF, value & 0xFF]);
      rxBuf = [];
      await writeRaw(pkt);
      await sleep(45);
    });
  }
  async function readReg(id, address, size, timeoutMs=35){
    return withLock(async () => {
      const pkt = buildPacket([id & 0xFF, 0x04, 0x02, address & 0xFF, size & 0xFF]);
      rxBuf = [];
      await writeRaw(pkt);
      const fr = await waitFrame(id, timeoutMs);
      if (!fr) return null;
      const err = fr[4];
      if (err !== 0) return null;
      const paramsLen = fr[3] - 2;
      return fr.slice(5, 5 + paramsLen);
    });
  }

  async function changeIdBroadcastLikeScript(newId){
    newId = Number(newId);
    if (!(newId>=1 && newId<=253)) throw new Error("ID èŒƒå›´ 1~253");
    await writeReg(BROADCAST_ID, ADDR_LOCK, 0);
    await writeReg(BROADCAST_ID, ADDR_TORQUE, 0);
    await writeReg(BROADCAST_ID, ADDR_ID, newId);
    await sleep(150);
    await writeReg(newId, ADDR_LOCK, 1);
    let ok = await ping(newId, 160);
    if (!ok){ await sleep(250); ok = await ping(newId, 160); }
    if (!ok) throw new Error("éªŒè¯å¤±è´¥");
  }
  async function changeIdTargeted(oldId, newId){
    oldId = Number(oldId); newId = Number(newId);
    if (!(oldId>=0 && oldId<=253)) throw new Error("æ—§IDä¸åˆæ³•");
    if (!(newId>=1 && newId<=253)) throw new Error("æ–°IDéœ€åœ¨ 1~253");
    await writeReg(oldId, ADDR_LOCK, 0);
    await writeReg(oldId, ADDR_TORQUE, 0);
    await writeReg(oldId, ADDR_ID, newId);
    await sleep(150);
    await writeReg(newId, ADDR_LOCK, 1);
    let ok = await ping(newId, 160);
    if (!ok){ await sleep(250); ok = await ping(newId, 160); }
    if (!ok) throw new Error("éªŒè¯å¤±è´¥");
  }

  async function writeMiddleCalibrate(id){ await writeReg(id, 0x28, 128); }
  async function resetState(id){
    return withLock(async () => {
      const pkt = buildPacket([id & 0xFF, 0x02, 0x0A]);
      rxBuf = [];
      await writeRaw(pkt);
      await sleep(55);
    });
  }

  // è¡¨æ ¼ï¼šåª hint åœ¨çº¿èˆµæœºè¡Œï¼›åªåœ¨æ‰«ææ›´æ–°è¡Œé›†åˆ
  function ensureDevice(id){
    if (!devices.has(id)) devices.set(id, {online:false, pos:null, ts:null, failCount:0, row:null});
    ensureRow(id);
  }
  function ensureRow(id){
    const d = devices.get(id);
    if (d.row) return d.row;

    const tr = document.createElement("tr");
    tr.dataset.id = String(id);

    const tdId = document.createElement("td"); tdId.textContent = String(id);
    const tdOnline = document.createElement("td"); tdOnline.textContent = "";
    const tdPos = document.createElement("td"); tdPos.textContent = "";
    const tdTs = document.createElement("td"); tdTs.textContent = "";

    const tdChange = document.createElement("td");
    const input = document.createElement("input");
    input.className = "mini";
    input.inputMode = "numeric";
    input.placeholder = "æ–°ID";
    const btnChange = document.createElement("button");
    btnChange.textContent = "æ”¹ID";
    btnChange.dataset.action = "change";
    btnChange.dataset.id = String(id);
    tdChange.appendChild(input);
    tdChange.appendChild(document.createTextNode(" "));
    tdChange.appendChild(btnChange);

    const tdMid = document.createElement("td");
    const btnMid = document.createElement("button");
    btnMid.textContent = "å†™40=128";
    btnMid.dataset.action = "mid";
    btnMid.dataset.id = String(id);
    tdMid.appendChild(btnMid);

    const tdRst = document.createElement("td");
    const btnRst = document.createElement("button");
    btnRst.textContent = "RESET";
    btnRst.dataset.action = "rst";
    btnRst.dataset.id = String(id);
    tdRst.appendChild(btnRst);

    tr.append(tdId, tdOnline, tdPos, tdTs, tdChange, tdMid, tdRst);
    tbody.appendChild(tr);

    input.addEventListener("input", () => persistTableState());
    d.row = {tr, tdOnline, tdPos, tdTs, input, btnChange, btnMid, btnRst};
    return d.row;
  }
  function updateRow(id){
    const d = devices.get(id);
    if (!d || !d.row) return;
    d.row.tdOnline.textContent = d.online ? "âœ…" : "";
    d.row.tdPos.textContent = (d.pos ?? "");
    d.row.tdTs.textContent = d.ts ? new Date(d.ts).toLocaleTimeString() : "";
    const dis = !d.online || !port;
    d.row.btnChange.disabled = dis;
    d.row.btnMid.disabled = dis;
    d.row.btnRst.disabled = dis;
  }
  function removeRow(id){
    const d = devices.get(id);
    if (d && d.row && d.row.tr) d.row.tr.remove();
    devices.delete(id);
  }

  tbody.addEventListener("click", async (ev) => {
    const btn = ev.target.closest("button");
    if (!btn) return;
    const action = btn.dataset.action;
    const id = Number(btn.dataset.id);
    if (!port) return;

    try{
      if (safeOneServoEl.checked){
        const ok = confirm("å†™æ“ä½œå‰ç¡®è®¤ï¼šå½“å‰æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºï¼Ÿ\nï¼ˆå•è¡Œæ”¹IDä¸ºå®šå‘å†™ï¼Œä½†ä»å»ºè®®åªæ¥1ä¸ªã€‚ï¼‰");
        if (!ok) return;
      }
      btn.disabled = true;
      const d = devices.get(id);
      if (!d || !d.online) throw new Error("å½“å‰èˆµæœºä¸åœ¨çº¿");

      if (action === "change"){
        const newId = Number(d.row.input.value);
        if (!Number.isFinite(newId)) throw new Error("è¯·è¾“å…¥æ–°ID");
        log(`æ”¹IDï¼ˆå®šå‘ï¼‰ï¼š${id} -> ${newId}`);
        await changeIdTargeted(id, newId);
        log("âœ… æ”¹IDæˆåŠŸ");
        removeRow(id);
        ensureDevice(newId);
        devices.get(newId).online = true;
        devices.get(newId).ts = Date.now();
        updateRow(newId);
        persistTableState();
      } else if (action === "mid"){
        log(`å†™40=128ï¼šID=${id}`);
        await writeMiddleCalibrate(id);
        log("âœ… å†™å…¥å®Œæˆ");
      } else if (action === "rst"){
        log(`RESETï¼šID=${id}`);
        await resetState(id);
        log("âœ… å·²å‘é€ RESET");
      }
    } catch(e){
      log(`æ“ä½œå¤±è´¥: ${e.message || e}`);
    } finally {
      btn.disabled = false;
    }
  });

  // æ‰«æä¸€æ¬¡ï¼šåªæ˜¾ç¤ºåœ¨çº¿èˆµæœº
  async function scanOnce(){
    const start = Number(scanStartEl.value);
    const end = Number(scanEndEl.value);
    if (!Number.isFinite(start)||!Number.isFinite(end)||start<1||end>253||start>end){
      alert("æ‰«æèŒƒå›´ä¸åˆæ³•ï¼ˆ1~253 ä¸” èµ·å§‹<=ç»“æŸï¼‰");
      return;
    }
    scanStateEl.textContent = "æ‰«æä¸­...";

    const onlineIds = [];
    for (let id=start; id<=end; id++){
      const ok = await ping(id, 70);
      if (ok) onlineIds.push(id);
    }

    // æ‰«ææ—¶æ›´æ–°è¡Œé›†åˆï¼šæ¸…ç©ºå¹¶é‡å»ºï¼ˆåªåœ¨çº¿ï¼‰
    tbody.innerHTML = "";
    devices.clear();

    for (const id of onlineIds){
      ensureDevice(id);
      const d = devices.get(id);
      d.online = true;
      d.ts = Date.now();
      updateRow(id);
    }

    scanStateEl.textContent = `æ‰«æå®Œæˆï¼šåœ¨çº¿ ${onlineIds.length} ä¸ª`;
    persistInputs();
    persistTableState();
    if (posEnableEl.checked) ensurePosLoop();
  }

  // å®æ—¶ä½ç½®/åœ¨çº¿åˆ·æ–°ï¼šè¯»ä¸åˆ°ä½ç½® => ç¦»çº¿
  const failThreshold = 3;
  let posLoopRunning=false;
  async function posLoop(){
    posLoopRunning = true;
    posStateEl.textContent = "è¿è¡Œä¸­";
    while (posLoopRunning && port){
      const cycleStart = performance.now();
      const period = Math.max(20, Number(posPeriodEl.value)||50);

      const ids = Array.from(devices.keys());
      for (const id of ids){
        const d = devices.get(id);
        if (!d) continue;

        const params = await readReg(id, 0x38, 2, 30);
        if (!params || params.length < 2){
          d.failCount = (d.failCount || 0) + 1;
          if (d.failCount >= failThreshold){
            d.online = false;
            d.pos = null;
          }
          updateRow(id);
          continue;
        }
        const pos = params[0] | (params[1]<<8);
        d.pos = pos;
        d.ts = Date.now();
        d.failCount = 0;
        d.online = true;
        updateRow(id);
      }

      const elapsed = performance.now() - cycleStart;
      const rest = Math.max(0, period - elapsed);
      if (rest) await sleep(rest);
      else await sleep(0);
    }
    posStateEl.textContent = "å·²åœæ­¢";
  }
  function ensurePosLoop(){
    if (!posEnableEl.checked || !port) return;
    if (posLoopRunning) return;
    posLoop();
  }
  function stopPosLoop(){ posLoopRunning = false; }

  posEnableEl.addEventListener("change", () => {
    persistInputs();
    if (posEnableEl.checked) ensurePosLoop();
    else stopPosLoop();
  });

  // æµæ°´çº¿ï¼ˆä¸ v6 ä¸€è‡´ï¼‰
  let pipeRunning=false;
  let pipeTarget=1, pipeStart=1, pipeEnd=6;
  let pipeState="IDLE";
  let insertSeenCount=0;
  let removeLostSince=null;

  async function pipeLoop(){
    while (pipeRunning && port){
      const stepDelay = 80;
      try{
        if (pipeState === "WAIT_INSERT"){
          const seen = await pingBroadcastAny(80);
          insertSeenCount = seen ? (insertSeenCount + 1) : 0;
          if (insertSeenCount >= 3){
            pipeState = "PROGRAMMING";
            pipeStateEl.textContent = `æ£€æµ‹åˆ°æ’å…¥ï¼Œé…ç½® ID=${pipeTarget}...`;
            insertSeenCount = 0;
          } else {
            pipeStateEl.textContent = `ç­‰å¾…æ’å…¥ï¼ˆç›®æ ‡ ID=${pipeTarget}ï¼‰...`;
          }
        } else if (pipeState === "PROGRAMMING"){
          await changeIdBroadcastLikeScript(pipeTarget);
          log(`âœ… æµæ°´çº¿å†™å…¥æˆåŠŸï¼šID=${pipeTarget}`);
          pipeState = "WAIT_REMOVE";
          removeLostSince = null;
          pipeStateEl.textContent = `å·²å†™å…¥ ID=${pipeTarget}ï¼Œè¯·æ‹”æ‰èˆµæœº...`;
        } else if (pipeState === "WAIT_REMOVE"){
          const online = await ping(pipeTarget, 90);
          if (online){ removeLostSince = null; }
          else {
            if (removeLostSince == null) removeLostSince = performance.now();
            if (performance.now() - removeLostSince >= 1000){
              if (pipeTarget >= pipeEnd){
                log(`ğŸ‰ æµæ°´çº¿å®Œæˆï¼š${pipeStart}~${pipeEnd}`);
                pipeStateEl.textContent = `å®Œæˆï¼š${pipeStart}~${pipeEnd}`;
                pipeRunning = false;
              } else {
                pipeTarget += 1;
                pipeState = "WAIT_INSERT";
                insertSeenCount = 0;
                removeLostSince = null;
                log(`è¯·æ’å…¥ä¸‹ä¸€åªèˆµæœºï¼Œç›®æ ‡ ID=${pipeTarget}`);
              }
            }
          }
        }
      } catch(e){
        log(`æµæ°´çº¿å¼‚å¸¸: ${e.message || e}`);
        pipeRunning = false;
        pipeStateEl.textContent = "å¼‚å¸¸åœæ­¢";
      }
      await sleep(stepDelay);
    }
    btnPipeStart.disabled = !port;
    btnPipeStop.disabled = true;
    if (!pipeStateEl.textContent.startsWith("å®Œæˆ") && pipeStateEl.textContent !== "å¼‚å¸¸åœæ­¢"){
      pipeStateEl.textContent = "æœªè¿è¡Œ";
    }
  }
  function startPipeline(){
    pipeStart = Number(pipeStartEl.value);
    pipeEnd = Number(pipeEndEl.value);
    if (!Number.isFinite(pipeStart) || !Number.isFinite(pipeEnd) || pipeStart<1 || pipeEnd>253 || pipeStart>pipeEnd){
      alert("æµæ°´çº¿èŒƒå›´ä¸åˆæ³•ï¼ˆ1~253 ä¸” èµ·å§‹<=ç»“æŸï¼‰");
      return;
    }
    if (safeOneServoEl.checked){
      const ok = confirm("æµæ°´çº¿æ¨¡å¼ä¼šä½¿ç”¨å¹¿æ’­æ¢æµ‹ä¸å¹¿æ’­å†™å…¥ã€‚\nè¯·ç¡®è®¤ï¼šä»»æ„æ—¶åˆ»æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºã€‚");
      if (!ok) return;
    }
    pipeRunning = true;
    pipeTarget = pipeStart;
    pipeState = "WAIT_INSERT";
    insertSeenCount = 0;
    removeLostSince = null;
    btnPipeStart.disabled = true;
    btnPipeStop.disabled = false;
    pipeStateEl.textContent = `ç­‰å¾…æ’å…¥ï¼ˆç›®æ ‡ ID=${pipeTarget}ï¼‰...`;
    log(`æµæ°´çº¿å¯åŠ¨ï¼šå°†é…ç½® ID=${pipeStart}~${pipeEnd}ã€‚è¯·æ’å…¥ç¬¬ä¸€åªèˆµæœº...`);
    pipeLoop();
  }
  function stopPipeline(){
    pipeRunning = false;
    btnPipeStart.disabled = !port;
    btnPipeStop.disabled = true;
    pipeStateEl.textContent = "æœªè¿è¡Œ";
    log("æµæ°´çº¿å·²ä¸­æ–­");
  }

  // è¿æ¥/æ–­å¼€
  function setUiConnected(connected){
    btnConnect.disabled = connected;
    btnDisconnect.disabled = !connected;
    baudEl.disabled = connected;

    btnPipeStart.disabled = !connected;
    btnPipeStop.disabled = true;

    btnScanOnce.disabled = !connected;

    posEnableEl.disabled = !connected;
    posStateEl.textContent = "æœªè¿è¡Œ";

    scanStateEl.textContent = "æœªæ‰«æ";
    pipeStateEl.textContent = "æœªè¿è¡Œ";

    if (!connected) setStatus("æœªè¿æ¥");
    else setStatus("å·²è¿æ¥", "ok");

    for (const id of devices.keys()) updateRow(id);
  }

  btnConnect.onclick = async () => {
    try{
      if (!("serial" in navigator)){
        alert("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Web Serialã€‚è¯·ä½¿ç”¨æ¡Œé¢ç‰ˆ Chrome/Edgeã€‚");
        return;
      }
      const baudRate = Number(baudEl.value || "1000000");
      if (!Number.isFinite(baudRate) || baudRate<=0){ alert("æ³¢ç‰¹ç‡ä¸åˆæ³•"); return; }

      port = await navigator.serial.requestPort();
      await port.open({ baudRate });
      await startReadLoop();

      setUiConnected(true);
      log(`å·²è¿æ¥ä¸²å£ï¼Œbaud=${baudRate}`);
      if (posEnableEl.checked) ensurePosLoop();
    } catch(e){
      log(`è¿æ¥å¤±è´¥: ${e.message || e}`);
      setUiConnected(false);
      port = null;
    }
  };

  btnDisconnect.onclick = async () => {
    try{
      stopPipeline();
      stopPosLoop();
      await stopReadLoop();
      if (writer){ try{ writer.releaseLock(); } catch{} writer=null; }
      if (port){ await port.close(); }
      port=null;
      setUiConnected(false);
      log("å·²æ–­å¼€ä¸²å£");
    } catch(e){
      log(`æ–­å¼€å¤±è´¥: ${e.message || e}`);
    }
  };

  // ç»‘å®š
  btnScanOnce.onclick = () => scanOnce().catch(e=>log(`æ‰«æå¤±è´¥: ${e.message||e}`));
  btnPipeStart.onclick = () => { persistInputs(); startPipeline(); };
  btnPipeStop.onclick = () => stopPipeline();
  btnClearLog.onclick = () => { logEl.textContent = ""; };

  // å¯åŠ¨ï¼šæ¢å¤å¹¶ä¿å­˜ä¸€æ¬¡
  restoreFromLocalStorage();
  persistInputs();
  setUiConnected(false);
})();
</script>
</body>
</html>
