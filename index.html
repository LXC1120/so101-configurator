<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>èˆµæœºé…ç½®å·¥å…·ï¼ˆWeb Serialï¼‰</title>
  <style>
    :root{color-scheme:light dark}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",sans-serif;max-width:1020px;margin:0 auto;padding:18px;line-height:1.45}
    h1{font-size:20px;margin:0 0 10px}
    h2{font-size:16px;margin:0 0 10px}
    .card{border:1px solid rgba(127,127,127,.25);border-radius:14px;padding:14px;margin:12px 0;box-shadow:0 2px 10px rgba(0,0,0,.05)}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    label{display:flex;gap:8px;align-items:center}
    input,select,button{font:inherit}
    input,select{padding:8px 10px;border-radius:10px;border:1px solid rgba(127,127,127,.35)}
    input{width:110px}
    button{padding:9px 12px;border-radius:12px;border:1px solid rgba(127,127,127,.35);cursor:pointer}
    button:disabled{opacity:.45;cursor:not-allowed}
    .small{font-size:12px;opacity:.85}
    .pill{display:inline-block;padding:2px 10px;border:1px solid rgba(127,127,127,.35);border-radius:999px}
    .ok{color:#0a7a2f}
    .warn{color:#b45309}
    pre{background:rgba(0,0,0,.85);color:#e8eefc;padding:12px;border-radius:14px;overflow:auto;max-height:340px}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media (min-width:980px){.grid{grid-template-columns:1fr 1fr}}
    table{border-collapse:collapse;width:100%}
    th,td{border-bottom:1px solid rgba(127,127,127,.22);padding:6px 8px;text-align:left;font-size:13px;vertical-align:middle}
    th{opacity:.9}
    .mini{width:86px}
  </style>
</head>
<body>
  <h1>èˆµæœºé…ç½®å·¥å…·ï¼ˆWeb Serial / æ¡Œé¢ Chromeï¼‰</h1>
  <div class="small">
    <span class="pill" id="statusPill">æœªè¿æ¥</span>
    <span class="pill">å¤–æ¥ç”µæºï½œTX/RX äº¤å‰ï½œGND å…±åœ°</span>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <button id="btnConnect">è¿æ¥ä¸²å£</button>
        <button id="btnDisconnect" disabled>æ–­å¼€</button>
      </div>
      <label>æ³¢ç‰¹ç‡ <input id="baud" inputmode="numeric" value="1000000"/></label>
    </div>
    <div class="row small" style="margin-top:10px;justify-content:space-between">
      <span class="warn">Web Serial ä»…åœ¨ HTTPSï¼ˆæˆ– http://localhostï¼‰å¯ç”¨ï¼›è¯·ä½¿ç”¨æ¡Œé¢ Chrome/Edgeã€‚</span>
      <label style="gap:10px"><input id="safeOneServo" type="checkbox" checked/>å†™æ“ä½œå‰æé†’â€œä¸€æ¬¡åªæ¥1ä¸ªèˆµæœºâ€</label>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>æµæ°´çº¿é…ç½®ï¼ˆè‡ªåŠ¨ç›‘æ§æ’æ‹”ï¼‰</h2>
      <div class="row">
        <label>èµ·å§‹ID <input id="pipeStart" inputmode="numeric" value="1" /></label>
        <label>ç»“æŸID <input id="pipeEnd" inputmode="numeric" value="6" /></label>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btnPipeStart" disabled>å¼€å§‹æµæ°´çº¿</button>
        <button id="btnPipeStop" disabled>ä¸­æ–­</button>
        <span class="pill" id="pipeState">æœªè¿è¡Œ</span>
      </div>
      <p class="small">æµæ°´çº¿ç”¨å¹¿æ’­æ¢æµ‹æ’å…¥ï¼ˆPING 0xFEï¼‰+ å¹¿æ’­å†™å…¥ï¼Œè¯·ç¡®ä¿ä»»æ„æ—¶åˆ»æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºã€‚</p>
    </div>

    <div class="card">
      <h2>æ‰«æä¸å®æ—¶ä½ç½®</h2>
      <div class="row">
        <label>æ‰«æèµ·å§‹ <input id="scanStart" inputmode="numeric" value="1"/></label>
        <label>æ‰«æç»“æŸ <input id="scanEnd" inputmode="numeric" value="20"/></label>
        <button id="btnScanOnce" disabled>æ‰«æä¸€æ¬¡</button>
        <span class="pill" id="scanState">æœªæ‰«æ</span>
      </div>
      <div class="row" style="margin-top:10px">
        <label style="gap:10px"><input id="posEnable" type="checkbox" disabled checked/>è‡ªåŠ¨åˆ·æ–°ä½ç½®</label>
        <label>åˆ·æ–°ms <input id="posPeriod" class="mini" inputmode="numeric" value="50"/></label>
        <span class="pill" id="posState">æœªè¿è¡Œ</span>
      </div>
      <p class="small">ä½ç½®åˆ·æ–°ä»…è¯»å– 0x38 çš„ 2 å­—èŠ‚ï¼ˆæ›´çœé€šè®¯ï¼‰ã€‚v6 ä¿®å¤ï¼šæ‰«æåªè®¤â€œåŒ¹é…IDçš„å›åŒ…â€ï¼Œé¿å…è¯¯æŠ¥å¤§é‡åœ¨çº¿IDã€‚</p>
    </div>
  </div>

  <div class="card">
    <h2>åœ¨çº¿èˆµæœºè¡¨ï¼ˆæ¯è¡Œå«æ“ä½œï¼‰</h2>
    <table>
      <thead>
        <tr>
          <th>ID</th><th>åœ¨çº¿</th><th>ä½ç½®(0x38)</th><th>æ›´æ–°æ—¶é—´</th>
          <th>æ”¹ID</th><th>ä¸­å€¼</th><th>RESET</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
    <p class="small">æç¤ºï¼šä¸ºé¿å…â€œä½ç½®åˆ·æ–°æŠŠè¾“å…¥æ¡†æ¸…ç©ºâ€ï¼Œè¡¨æ ¼é‡‡ç”¨â€œå¢é‡æ›´æ–°â€è€Œä¸æ˜¯æ¯æ¬¡é‡ç»˜æ•´è¡¨ã€‚</p>
  </div>

  <div class="card">
    <h2>æ—¥å¿—</h2>
    <pre id="log"></pre>
    <div class="row small" style="justify-content:space-between;margin-top:10px">
      <span>æç¤ºï¼šè¿æ¥æ—¶ä¼šå¼¹çª—é€‰æ‹©ä¸²å£è®¾å¤‡ï¼Œè¿™æ˜¯æ­£å¸¸æƒé™æœºåˆ¶ã€‚</span>
      <button id="btnClearLog">æ¸…ç©ºæ—¥å¿—</button>
    </div>
  </div>

<script>
(() => {
  // ====== å¸¸é‡ï¼ˆä¸ä½ è„šæœ¬ä¸€è‡´ï¼‰======
  const BROADCAST_ID = 0xFE;
  const ADDR_ID     = 0x05;
  const ADDR_LOCK   = 0x37;
  const ADDR_TORQUE = 0x28; // 40

  // ä¸²å£çŠ¶æ€
  let port=null, writer=null, reader=null, readLoopRunning=false;
  let rxBuf=[];

  // ä¸²å£äº’æ–¥é”ï¼šé¿å…æ‰«æ/ä½ç½®åˆ·æ–°/æŒ‰é’®å†™å…¥å¹¶å‘å¯¼è‡´ä¸²å£å›åŒ…ä¸²å°
  let opChain = Promise.resolve();
  function withLock(fn){
    const next = opChain.then(fn, fn);
    opChain = next.catch(()=>{});
    return next;
  }

  // è®¾å¤‡è¡¨ï¼šid -> {online, pos, ts, row:{...elements}}
  const devices = new Map();

  // UI
  const logEl = document.getElementById('log');
  const statusPill = document.getElementById('statusPill');
  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const baudEl = document.getElementById('baud');
  const safeOneServoEl = document.getElementById('safeOneServo');

  const pipeStartEl = document.getElementById('pipeStart');
  const pipeEndEl = document.getElementById('pipeEnd');
  const btnPipeStart = document.getElementById('btnPipeStart');
  const btnPipeStop = document.getElementById('btnPipeStop');
  const pipeStateEl = document.getElementById('pipeState');

  const scanStartEl = document.getElementById('scanStart');
  const scanEndEl = document.getElementById('scanEnd');
  const btnScanOnce = document.getElementById('btnScanOnce');
  const scanStateEl = document.getElementById('scanState');

  const posEnableEl = document.getElementById('posEnable');
  const posPeriodEl = document.getElementById('posPeriod');
  const posStateEl = document.getElementById('posState');

  const tbody = document.getElementById('tbody');
  const btnClearLog = document.getElementById('btnClearLog');

  function setStatus(text, kind="") {
    statusPill.textContent = text;
    statusPill.className = "pill " + kind;
  }
  function log(msg) {
    const t = new Date().toLocaleTimeString();
    logEl.textContent += `[${t}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // ====== åè®®ï¼šæ ¡éªŒä¸ç»„åŒ… ======
  function calcChecksum(dataBytes) {
    let sum=0;
    for (const b of dataBytes) sum += (b & 0xFF);
    return (~sum) & 0xFF;
  }
  function buildPacket(dataBytes) {
    const chk = calcChecksum(dataBytes);
    return new Uint8Array([0xFF, 0xFF, ...dataBytes, chk]);
  }
  function verifyFrameChecksum(frame){
    // frame: FF FF ID LEN ... CHK
    if (!frame || frame.length < 6) return false;
    const id = frame[2];
    const len = frame[3];
    const total = 2 + 1 + 1 + len;
    if (frame.length !== total) return false;
    const dataBytes = frame.slice(2, frame.length - 1); // ID..last-1
    const chk = calcChecksum(dataBytes);
    return chk === frame[frame.length - 1];
  }

  async function ensureWriter(){
    if (!port) throw new Error("æœªè¿æ¥ä¸²å£");
    if (!writer) writer = port.writable.getWriter();
  }
  async function writeRaw(u8){
    await ensureWriter();
    await writer.write(u8);
  }

  // ====== è¯»å–ï¼šç¼“å­˜æ”¶åˆ°çš„å­—èŠ‚ ======
  async function startReadLoop(){
    reader = port.readable.getReader();
    readLoopRunning = true;
    rxBuf = [];
    (async () => {
      try{
        while (readLoopRunning){
          const {value, done} = await reader.read();
          if (done) break;
          if (value && value.length){
            for (const b of value) rxBuf.push(b);
            if (rxBuf.length > 8192) rxBuf = rxBuf.slice(-4096);
          }
        }
      } catch(e){
        log(`è¯»å–å¼‚å¸¸: ${e.message || e}`);
      }
    })();
  }
  async function stopReadLoop(){
    readLoopRunning = false;
    if (reader){
      try{ await reader.cancel(); } catch{}
      try{ reader.releaseLock(); } catch{}
      reader = null;
    }
    rxBuf=[];
  }

  // ====== å¸§è§£æï¼šä» rxBuf ä¸­æŠ½å–ä¸€å¸§ ======
  function tryPopFrame(){
    for (let i=0; i+6<=rxBuf.length; i++){
      if (rxBuf[i]!==0xFF || rxBuf[i+1]!==0xFF) continue;
      const len = rxBuf[i+3];
      const total = 2 + 1 + 1 + len;
      if (i+total > rxBuf.length) return null;
      const frame = rxBuf.slice(i, i+total);
      rxBuf = rxBuf.slice(i+total);
      // æ ¡éªŒå¤±è´¥å°±ç»§ç»­æ‰¾ä¸‹ä¸€å¸§ï¼ˆé¿å…å™ªå£°å¯¼è‡´è¯¯æŠ¥åœ¨çº¿ï¼‰
      if (!verifyFrameChecksum(frame)) continue;
      return frame;
    }
    if (rxBuf.length > 4096) rxBuf = rxBuf.slice(-1024);
    return null;
  }

  async function waitFrame(expectedId, timeoutMs){
    const start = performance.now();
    while (performance.now() - start < timeoutMs){
      const fr = tryPopFrame();
      if (!fr){ await sleep(1); continue; }
      const id = fr[2];
      if (expectedId == null || id === expectedId) return fr; // expectedId=null è¡¨ç¤ºæ¥å—ä»»æ„
      // ä¸åŒ¹é…ï¼šä¸¢å¼ƒï¼Œç»§ç»­ç­‰ï¼ˆé¿å…æŠŠåˆ«çš„å‘½ä»¤å›åŒ…å½“æˆå½“å‰ pingï¼‰
    }
    return null;
  }

  // ====== åŸºæœ¬æŒ‡ä»¤ï¼ˆä¸¥æ ¼åŒ¹é…å›åŒ…IDï¼Œé¿å…æ‰«æè¯¯æŠ¥ï¼‰ ======
  async function ping(id, timeoutMs=90){
    return withLock(async () => {
      const data = [id & 0xFF, 0x02, 0x01];
      const pkt = buildPacket(data);
      rxBuf = [];
      await writeRaw(pkt);
      const fr = await waitFrame(id, timeoutMs);
      return !!fr;
    });
  }

  async function writeReg(id, address, value){
    return withLock(async () => {
      const data = [id & 0xFF, 0x04, 0x03, address & 0xFF, value & 0xFF];
      const pkt = buildPacket(data);
      rxBuf = [];
      await writeRaw(pkt);
      await sleep(45);
    });
  }

  async function readReg(id, address, size, timeoutMs=35){
    return withLock(async () => {
      const data = [id & 0xFF, 0x04, 0x02, address & 0xFF, size & 0xFF];
      const pkt = buildPacket(data);
      rxBuf = [];
      await writeRaw(pkt);
      const fr = await waitFrame(id, timeoutMs);
      if (!fr) return null;
      const err = fr[4];
      if (err !== 0) return null;
      const paramsLen = fr[3] - 2;
      return fr.slice(5, 5 + paramsLen);
    });
  }

  // ====== å¹¿æ’­ pingï¼ˆæµæ°´çº¿æ’å…¥æ£€æµ‹ç”¨ï¼šæ¥å—ä»»æ„å›åŒ…ï¼‰======
  async function pingBroadcastAny(timeoutMs=90){
    return withLock(async () => {
      const data = [BROADCAST_ID, 0x02, 0x01];
      const pkt = buildPacket(data);
      rxBuf = [];
      await writeRaw(pkt);
      const fr = await waitFrame(null, timeoutMs);
      return !!fr;
    });
  }

  // ====== æ”¹å·ï¼ˆå¹¿æ’­ç‰ˆï¼šæµæ°´çº¿ï¼‰======
  async function changeIdBroadcastLikeScript(newId){
    newId = Number(newId);
    if (!(newId>=1 && newId<=253)) throw new Error("ID èŒƒå›´ 1~253");
    await writeReg(BROADCAST_ID, ADDR_LOCK, 0);
    await writeReg(BROADCAST_ID, ADDR_TORQUE, 0);
    await writeReg(BROADCAST_ID, ADDR_ID, newId);
    await sleep(150);
    await writeReg(newId, ADDR_LOCK, 1);

    let ok = await ping(newId, 160);
    if (!ok){ await sleep(250); ok = await ping(newId, 160); }
    if (!ok) throw new Error("éªŒè¯å¤±è´¥");
  }

  // ====== æ”¹å·ï¼ˆå®šå‘ç‰ˆï¼šè¡¨æ ¼å•è¡Œï¼‰======
  async function changeIdTargeted(oldId, newId){
    oldId = Number(oldId); newId = Number(newId);
    if (!(oldId>=0 && oldId<=253)) throw new Error("æ—§IDä¸åˆæ³•");
    if (!(newId>=1 && newId<=253)) throw new Error("æ–°IDéœ€åœ¨ 1~253");
    await writeReg(oldId, ADDR_LOCK, 0);
    await writeReg(oldId, ADDR_TORQUE, 0);
    await writeReg(oldId, ADDR_ID, newId);
    await sleep(150);
    await writeReg(newId, ADDR_LOCK, 1);

    let ok = await ping(newId, 160);
    if (!ok){ await sleep(250); ok = await ping(newId, 160); }
    if (!ok) throw new Error("éªŒè¯å¤±è´¥");
  }

  async function writeMiddleCalibrate(id){
    await writeReg(id, 0x28, 128);
  }
  async function resetState(id){
    return withLock(async () => {
      const data = [id & 0xFF, 0x02, 0x0A];
      const pkt = buildPacket(data);
      rxBuf = [];
      await writeRaw(pkt);
      await sleep(55);
    });
  }

  // ====== è¡¨æ ¼ï¼šå¢é‡æ›´æ–°ï¼Œé¿å…è¾“å…¥æ¡†ä¸¢å¤± & æå‡åˆ·æ–°é€Ÿåº¦ ======
  function ensureRow(id){
    if (devices.has(id) && devices.get(id).row) return devices.get(id).row;

    if (!devices.has(id)) devices.set(id, {online:false, pos:null, ts:null});
    const d = devices.get(id);

    const tr = document.createElement("tr");
    tr.dataset.id = String(id);

    const tdId = document.createElement("td"); tdId.textContent = String(id);
    const tdOnline = document.createElement("td"); tdOnline.textContent = "";
    const tdPos = document.createElement("td"); tdPos.textContent = "";
    const tdTs = document.createElement("td"); tdTs.textContent = "";

    const tdChange = document.createElement("td");
    const input = document.createElement("input");
    input.className = "mini";
    input.inputMode = "numeric";
    input.placeholder = "æ–°ID";
    input.dataset.newid = String(id);
    const btnChange = document.createElement("button");
    btnChange.textContent = "æ”¹ID";
    btnChange.dataset.action = "change";
    btnChange.dataset.id = String(id);
    tdChange.appendChild(input);
    tdChange.appendChild(document.createTextNode(" "));
    tdChange.appendChild(btnChange);

    const tdMid = document.createElement("td");
    const btnMid = document.createElement("button");
    btnMid.textContent = "å†™40=128";
    btnMid.dataset.action = "mid";
    btnMid.dataset.id = String(id);
    tdMid.appendChild(btnMid);

    const tdRst = document.createElement("td");
    const btnRst = document.createElement("button");
    btnRst.textContent = "RESET";
    btnRst.dataset.action = "rst";
    btnRst.dataset.id = String(id);
    tdRst.appendChild(btnRst);

    tr.append(tdId, tdOnline, tdPos, tdTs, tdChange, tdMid, tdRst);
    tbody.appendChild(tr);

    d.row = {tr, tdOnline, tdPos, tdTs, input, btnChange, btnMid, btnRst};
    return d.row;
  }

  function updateRow(id){
    const d = devices.get(id);
    const r = ensureRow(id);
    r.tdOnline.textContent = d.online ? "âœ…" : "";
    r.tdPos.textContent = (d.pos ?? "");
    r.tdTs.textContent = d.ts ? new Date(d.ts).toLocaleTimeString() : "";
    const dis = !d.online || !port;
    r.btnChange.disabled = dis;
    r.btnMid.disabled = dis;
    r.btnRst.disabled = dis;
  }

  function updateAllRows(){
    for (const id of Array.from(devices.keys()).sort((a,b)=>a-b)) updateRow(id);
  }

  tbody.addEventListener("click", async (ev) => {
    const btn = ev.target.closest("button");
    if (!btn) return;
    const action = btn.dataset.action;
    const id = Number(btn.dataset.id);
    if (!port) return;

    try{
      if (safeOneServoEl.checked){
        const ok = confirm("å†™æ“ä½œå‰ç¡®è®¤ï¼šå½“å‰æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºï¼Ÿ\nï¼ˆæµæ°´çº¿å¼ºä¾èµ–åªæ¥1ä¸ªï¼›å•è¡Œæ”¹IDæ˜¯å®šå‘å†™ï¼Œä»å»ºè®®åªæ¥1ä¸ªã€‚ï¼‰");
        if (!ok) return;
      }
      btn.disabled = true;

      if (action === "change"){
        const row = ensureRow(id);
        const newId = Number(row.input.value);
        if (!Number.isFinite(newId)) throw new Error("è¯·è¾“å…¥æ–°ID");
        log(`æ”¹IDï¼ˆå®šå‘ï¼‰ï¼š${id} -> ${newId}`);
        await changeIdTargeted(id, newId);
        log("âœ… æ”¹IDæˆåŠŸ");
        // æ›´æ–°è¡¨ï¼šæ—§IDç¦»çº¿ï¼Œæ–°IDåŠ å…¥å¹¶æ ‡åœ¨çº¿
        if (!devices.has(newId)) devices.set(newId, {online:true, pos:null, ts:Date.now(), row:null});
        const od = devices.get(id); od.online = false;
        const nd = devices.get(newId); nd.online = true; nd.ts = Date.now();
        updateAllRows();
      } else if (action === "mid"){
        log(`å†™40=128ï¼šID=${id}`);
        await writeMiddleCalibrate(id);
        log("âœ… å†™å…¥å®Œæˆ");
      } else if (action === "rst"){
        log(`RESETï¼šID=${id}`);
        await resetState(id);
        log("âœ… å·²å‘é€ RESET");
      }
    } catch(e){
      log(`æ“ä½œå¤±è´¥: ${e.message || e}`);
    } finally {
      btn.disabled = false;
    }
  });

  // ====== æ‰«æä¸€æ¬¡ï¼ˆv6ï¼šä¸¥æ ¼åŒ¹é…å›åŒ…IDï¼Œé¿å…è¯¯æŠ¥ï¼‰ ======
  async function scanOnce(){
    const start = Number(scanStartEl.value);
    const end = Number(scanEndEl.value);
    if (!Number.isFinite(start)||!Number.isFinite(end)||start<1||end>253||start>end){
      alert("æ‰«æèŒƒå›´ä¸åˆæ³•ï¼ˆ1~253 ä¸” èµ·å§‹<=ç»“æŸï¼‰");
      return;
    }
    scanStateEl.textContent = "æ‰«æä¸­...";
    for (let id=start; id<=end; id++){
      const ok = await ping(id, 70);
      if (!devices.has(id)) devices.set(id, {online:false, pos:null, ts:null, row:null});
      const d = devices.get(id);
      d.online = ok;
      if (ok) d.ts = Date.now();
      updateRow(id);
    }
    scanStateEl.textContent = "æ‰«æå®Œæˆ";
    if (posEnableEl.checked) ensurePosLoop();
  }

  // ====== å®æ—¶ä½ç½®ï¼ˆåªè¯» 0x38 ä¸¤å­—èŠ‚ï¼‰ï¼Œå¹¶æŒ‰å‘¨æœŸç›®æ ‡å¯¹é½ ======
  let posLoopRunning=false;
  async function posLoop(){
    posLoopRunning = true;
    posStateEl.textContent = "è¿è¡Œä¸­";
    while (posLoopRunning && port){
      const cycleStart = performance.now();
      const period = Math.max(20, Number(posPeriodEl.value)||50);

      const ids = Array.from(devices.keys()).filter(id => devices.get(id).online);
      for (const id of ids){
        const params = await readReg(id, 0x38, 2, 28);
        if (!params || params.length < 2) continue;
        const pos = params[0] | (params[1]<<8);
        const d = devices.get(id);
        d.pos = pos;
        d.ts = Date.now();
        updateRow(id);
      }

      const elapsed = performance.now() - cycleStart;
      const rest = Math.max(0, period - elapsed);
      if (rest) await sleep(rest);
      else await sleep(0);
    }
    posStateEl.textContent = "å·²åœæ­¢";
  }

  function ensurePosLoop(){
    if (!posEnableEl.checked || !port) return;
    if (posLoopRunning) return;
    posLoop();
  }
  function stopPosLoop(){ posLoopRunning = false; }

  posEnableEl.addEventListener("change", () => {
    if (posEnableEl.checked) ensurePosLoop();
    else stopPosLoop();
  });

  // ====== æµæ°´çº¿ï¼ˆä¿æŒ v5 çš„å•å¾ªç¯+å»æŠ–ï¼Œä½†ç”¨å¹¿æ’­ any å›åŒ…ï¼‰ ======
  let pipeRunning=false;
  let pipeTarget=1, pipeStart=1, pipeEnd=6;
  let pipeState="IDLE";
  let insertSeenCount=0;
  let removeLostSince=null;

  async function pipeLoop(){
    while (pipeRunning && port){
      const stepDelay = 80;
      try{
        if (pipeState === "WAIT_INSERT"){
          const seen = await pingBroadcastAny(80);
          insertSeenCount = seen ? (insertSeenCount + 1) : 0;
          if (insertSeenCount >= 3){
            pipeState = "PROGRAMMING";
            pipeStateEl.textContent = `æ£€æµ‹åˆ°æ’å…¥ï¼Œé…ç½® ID=${pipeTarget}...`;
            insertSeenCount = 0;
          } else {
            pipeStateEl.textContent = `ç­‰å¾…æ’å…¥ï¼ˆç›®æ ‡ ID=${pipeTarget}ï¼‰...`;
          }
        } else if (pipeState === "PROGRAMMING"){
          await changeIdBroadcastLikeScript(pipeTarget);
          log(`âœ… æµæ°´çº¿å†™å…¥æˆåŠŸï¼šID=${pipeTarget}`);
          pipeState = "WAIT_REMOVE";
          removeLostSince = null;
          pipeStateEl.textContent = `å·²å†™å…¥ ID=${pipeTarget}ï¼Œè¯·æ‹”æ‰èˆµæœº...`;
        } else if (pipeState === "WAIT_REMOVE"){
          const online = await ping(pipeTarget, 90);
          if (online){
            removeLostSince = null;
          } else {
            if (removeLostSince == null) removeLostSince = performance.now();
            if (performance.now() - removeLostSince >= 1000){
              if (pipeTarget >= pipeEnd){
                log(`ğŸ‰ æµæ°´çº¿å®Œæˆï¼š${pipeStart}~${pipeEnd}`);
                pipeStateEl.textContent = `å®Œæˆï¼š${pipeStart}~${pipeEnd}`;
                pipeRunning = false;
              } else {
                pipeTarget += 1;
                pipeState = "WAIT_INSERT";
                insertSeenCount = 0;
                removeLostSince = null;
                log(`è¯·æ’å…¥ä¸‹ä¸€åªèˆµæœºï¼Œç›®æ ‡ ID=${pipeTarget}`);
              }
            }
          }
        }
      } catch(e){
        log(`æµæ°´çº¿å¼‚å¸¸: ${e.message || e}`);
        pipeRunning = false;
        pipeStateEl.textContent = "å¼‚å¸¸åœæ­¢";
      }
      await sleep(stepDelay);
    }
    btnPipeStart.disabled = !port;
    btnPipeStop.disabled = true;
    if (!pipeStateEl.textContent.startsWith("å®Œæˆ") && pipeStateEl.textContent !== "å¼‚å¸¸åœæ­¢"){
      pipeStateEl.textContent = "æœªè¿è¡Œ";
    }
  }

  function startPipeline(){
    pipeStart = Number(pipeStartEl.value);
    pipeEnd = Number(pipeEndEl.value);
    if (!Number.isFinite(pipeStart) || !Number.isFinite(pipeEnd) || pipeStart<1 || pipeEnd>253 || pipeStart>pipeEnd){
      alert("æµæ°´çº¿èŒƒå›´ä¸åˆæ³•ï¼ˆ1~253 ä¸” èµ·å§‹<=ç»“æŸï¼‰");
      return;
    }
    if (safeOneServoEl.checked){
      const ok = confirm("æµæ°´çº¿æ¨¡å¼ä¼šä½¿ç”¨å¹¿æ’­æ¢æµ‹ä¸å¹¿æ’­å†™å…¥ã€‚\nè¯·ç¡®è®¤ï¼šä»»æ„æ—¶åˆ»æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºã€‚");
      if (!ok) return;
    }
    pipeRunning = true;
    pipeTarget = pipeStart;
    pipeState = "WAIT_INSERT";
    insertSeenCount = 0;
    removeLostSince = null;
    btnPipeStart.disabled = true;
    btnPipeStop.disabled = false;
    pipeStateEl.textContent = `ç­‰å¾…æ’å…¥ï¼ˆç›®æ ‡ ID=${pipeTarget}ï¼‰...`;
    log(`æµæ°´çº¿å¯åŠ¨ï¼šå°†é…ç½® ID=${pipeStart}~${pipeEnd}ã€‚è¯·æ’å…¥ç¬¬ä¸€åªèˆµæœº...`);
    pipeLoop();
  }

  function stopPipeline(){
    pipeRunning = false;
    btnPipeStart.disabled = !port;
    btnPipeStop.disabled = true;
    pipeStateEl.textContent = "æœªè¿è¡Œ";
    log("æµæ°´çº¿å·²ä¸­æ–­");
  }

  // ====== è¿æ¥/æ–­å¼€ ======
  function setUiConnected(connected){
    btnConnect.disabled = connected;
    btnDisconnect.disabled = !connected;
    baudEl.disabled = connected;

    btnPipeStart.disabled = !connected;
    btnPipeStop.disabled = true;

    btnScanOnce.disabled = !connected;

    posEnableEl.disabled = !connected;
    posStateEl.textContent = "æœªè¿è¡Œ";
    scanStateEl.textContent = "æœªæ‰«æ";
    pipeStateEl.textContent = "æœªè¿è¡Œ";

    if (!connected) setStatus("æœªè¿æ¥");
    else setStatus("å·²è¿æ¥", "ok");

    // æŒ‰é’®å¯ç”¨æ€§æ›´æ–°
    updateAllRows();
  }

  btnConnect.onclick = async () => {
    try{
      if (!("serial" in navigator)){
        alert("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Web Serialã€‚è¯·ä½¿ç”¨æ¡Œé¢ç‰ˆ Chrome/Edgeã€‚");
        return;
      }
      const baudRate = Number(baudEl.value || "1000000");
      if (!Number.isFinite(baudRate) || baudRate<=0){ alert("æ³¢ç‰¹ç‡ä¸åˆæ³•"); return; }

      port = await navigator.serial.requestPort();
      await port.open({ baudRate });
      await startReadLoop();

      setUiConnected(true);
      log(`å·²è¿æ¥ä¸²å£ï¼Œbaud=${baudRate}`);
      if (posEnableEl.checked) ensurePosLoop();
    } catch(e){
      log(`è¿æ¥å¤±è´¥: ${e.message || e}`);
      setUiConnected(false);
      port = null;
    }
  };

  btnDisconnect.onclick = async () => {
    try{
      stopPipeline();
      stopPosLoop();
      await stopReadLoop();
      if (writer){ try{ writer.releaseLock(); } catch{} writer=null; }
      if (port){ await port.close(); }
      port=null;
      setUiConnected(false);
      log("å·²æ–­å¼€ä¸²å£");
    } catch(e){
      log(`æ–­å¼€å¤±è´¥: ${e.message || e}`);
    }
  };

  // ç»‘å®š
  btnScanOnce.onclick = () => scanOnce().catch(e=>log(`æ‰«æå¤±è´¥: ${e.message||e}`));
  btnPipeStart.onclick = () => startPipeline();
  btnPipeStop.onclick = () => stopPipeline();
  btnClearLog.onclick = () => { logEl.textContent = ""; };

  // åˆå§‹
  setUiConnected(false);
})();
</script>
</body>
</html>
