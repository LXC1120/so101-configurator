<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>èˆµæœºé…ç½®å·¥å…·ï¼ˆWeb Serialï¼‰</title>
  <style>
    :root{color-scheme:light dark}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",sans-serif;max-width:980px;margin:0 auto;padding:18px;line-height:1.45}
    h1{font-size:20px;margin:0 0 10px}
    h2{font-size:16px;margin:0 0 10px}
    .card{border:1px solid rgba(127,127,127,.25);border-radius:14px;padding:14px;margin:12px 0;box-shadow:0 2px 10px rgba(0,0,0,.05)}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    label{display:flex;gap:8px;align-items:center}
    input,select,button{font:inherit}
    input,select{padding:8px 10px;border-radius:10px;border:1px solid rgba(127,127,127,.35)}
    input{width:140px}
    select{min-width:180px}
    button{padding:10px 14px;border-radius:12px;border:1px solid rgba(127,127,127,.35);cursor:pointer}
    button:disabled{opacity:.45;cursor:not-allowed}
    .ok{color:#0a7a2f}
    .warn{color:#b45309}
    .bad{color:#b91c1c}
    pre{background:rgba(0,0,0,.85);color:#e8eefc;padding:12px;border-radius:14px;overflow:auto;max-height:360px}
    code{background:rgba(127,127,127,.18);padding:2px 6px;border-radius:8px}
    .small{font-size:12px;opacity:.86}
    .pill{display:inline-block;padding:2px 10px;border:1px solid rgba(127,127,127,.35);border-radius:999px}
    .grid{display:grid;grid-template-columns:1fr;gap:10px}
    @media (min-width:900px){.grid{grid-template-columns:1fr 1fr}}
    table{border-collapse:collapse;width:100%}
    th,td{border-bottom:1px solid rgba(127,127,127,.25);padding:6px 8px;text-align:left;font-size:13px}
    th{opacity:.9}
  </style>
</head>
<body>
  <h1>èˆµæœºé…ç½®å·¥å…·ï¼ˆWeb Serial / Chromeï¼‰</h1>
  <div class="small">
    <span class="pill" id="statusPill">æœªè¿æ¥</span>
    <span class="pill">åè®®ï¼šFF FFâ€¦ï¼ˆä¸åŸè„šæœ¬ä¸€è‡´ï¼‰</span>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <button id="btnConnect">è¿æ¥ä¸²å£</button>
        <button id="btnDisconnect" disabled>æ–­å¼€</button>
      </div>
      <label>æ³¢ç‰¹ç‡
        <input id="baud" inputmode="numeric" value="1000000" />
      </label>
    </div>
    <p class="small warn" style="margin:10px 0 0">
      Web Serial ä»…åœ¨ <b>HTTPS</b>ï¼ˆæˆ– <code>http://localhost</code>ï¼‰å¯ç”¨ï¼›è¯·ä½¿ç”¨ <b>æ¡Œé¢ç‰ˆ</b> Chrome/Edgeã€‚
    </p>
  </div>

  <div class="grid">
    <div class="card">
      <h2>æµæ°´çº¿è‡ªåŠ¨é…ç½® IDï¼ˆæ’æ‹”å³å¯ï¼‰</h2>
      <div class="row">
        <label>èµ·å§‹ ID
          <input id="pipeStart" inputmode="numeric" min="1" max="253" value="1" />
        </label>
        <label>ç»“æŸ ID
          <input id="pipeEnd" inputmode="numeric" min="1" max="253" value="6" />
        </label>
        <label class="small" style="gap:10px">
          <input id="pipeConfirmOne" type="checkbox" />
          æˆ‘ç¡®è®¤ä»»ä½•æ—¶åˆ»æ€»çº¿ä¸Šåªä¼šæœ‰ <b>1 ä¸ª</b> èˆµæœº
        </label>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btnPipeStart" disabled>å¼€å§‹æµæ°´çº¿</button>
        <button id="btnPipeStop" disabled>ä¸­æ–­</button>
        <span class="small" id="pipeState">æœªè¿è¡Œ</span>
      </div>
      <p class="small warn" style="margin:10px 0 0">
        é€»è¾‘ï¼šæŒç»­å¹¿æ’­ PING æ£€æµ‹â€œæ’å…¥â€ï¼Œæ£€æµ‹åˆ°åæŒ‰é¡ºåºå†™å…¥ IDï¼Œå¹¶è¦æ±‚æ‹”æ‰åå†ç»§ç»­ä¸‹ä¸€åªã€‚
      </p>
    </div>

    <div class="card">
      <h2>å•ç‹¬æ”¹å·ï¼ˆä¿æŒåŸè„šæœ¬æµç¨‹ï¼‰</h2>
      <div class="row">
        <label>ç›®æ ‡æ–° IDï¼ˆ1-253ï¼‰
          <input id="newId" inputmode="numeric" min="1" max="253" value="1" />
        </label>
        <label class="small" style="gap:10px">
          <input id="confirmOneServo" type="checkbox" />
          æˆ‘ç¡®è®¤ç›®å‰åªè¿æ¥äº† <b>1 ä¸ª</b> èˆµæœº
        </label>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btnPingBroadcast" disabled>Ping å¹¿æ’­(0xFE)</button>
        <button id="btnDoChange" disabled>å¼€å§‹æ”¹å·</button>
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>æ‰«æèˆµæœºï¼ˆå‘ç°æœ‰å“ªäº›IDï¼‰</h2>
      <div class="row">
        <label>æ‰«æ ID ä»
          <input id="scanStart" inputmode="numeric" min="0" max="253" value="1" />
        </label>
        <label>åˆ°
          <input id="scanEnd" inputmode="numeric" min="0" max="253" value="20" />
        </label>
        <label>æ‰«æå‘¨æœŸ(ms)
          <input id="scanPeriod" inputmode="numeric" value="200" />
        </label>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btnScanStart" disabled>å¼€å§‹æ‰«æ</button>
        <button id="btnScanStop" disabled>åœæ­¢æ‰«æ</button>
        <span class="small" id="scanState">æœªè¿è¡Œ</span>
      </div>

      <div class="row" style="margin-top:10px">
        <label>ä½ç½®åˆ·æ–°(ms)
          <input id="posPeriod" inputmode="numeric" value="50" />
        </label>
        <button id="btnPosStart" disabled>å¼€å§‹å®æ—¶ä½ç½®</button>
        <button id="btnPosStop" disabled>åœæ­¢å®æ—¶ä½ç½®</button>
        <span class="small" id="posState">å®æ—¶ä½ç½®ï¼šæœªè¿è¡Œ</span>
      </div>

      <div style="margin-top:10px;overflow:auto;max-height:220px">
        <table>
          <thead><tr><th>ID</th><th>ä½ç½®</th><th>é€Ÿåº¦</th><th>è´Ÿè½½</th><th>ç”µå‹</th><th>æ¸©åº¦</th><th>æ›´æ–°æ—¶é—´</th></tr></thead>
          <tbody id="scanTableBody"><tr><td colspan="7" class="small">ï¼ˆå°šæœªæ‰«æï¼‰</td></tr></tbody>
        </table>
      </div>
      <p class="small" style="margin:10px 0 0">
        è¯»å–ï¼šä»åœ°å€ <code>0x38</code> è¿ç»­è¯»å– 8 å­—èŠ‚ï¼ˆä½ç½®/é€Ÿåº¦/è´Ÿè½½/ç”µå‹/æ¸©åº¦ï¼‰ã€‚
      </p>
    </div>

    <div class="card">
      <h2>ä¸­å€¼æ ¡å‡† / çŠ¶æ€é‡ç½®</h2>
      <div class="row">
        <label>ç›®æ ‡èˆµæœº ID
          <input id="actId" inputmode="numeric" min="0" max="253" value="1" />
        </label>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btnCenter" disabled>å†™40=128ï¼ˆä¸­å€¼æ ¡å‡†ï¼‰</button>
        <button id="btnResetState" disabled>çŠ¶æ€é‡ç½®(RESET 0x0A)</button>
      </div>
      <p class="small warn" style="margin:10px 0 0">
        ä¸­å€¼æ ¡å‡†ï¼šæŒ‰ä½ çš„éœ€æ±‚å‘ <code>0x28</code>ï¼ˆ40å·åœ°å€ï¼‰å†™å…¥ <code>128</code>ï¼›çŠ¶æ€é‡ç½®ä½¿ç”¨æŒ‡ä»¤ <code>0x0A</code>ï¼ˆæ— å‚æ•°ï¼‰ã€‚
      </p>
    </div>
  </div>

  <div class="card">
    <h2>æ—¥å¿—</h2>
    <pre id="log"></pre>
    <div class="row small" style="justify-content:space-between;margin-top:10px">
      <span>æç¤ºï¼šæµè§ˆå™¨ä¼šå¼¹çª—è®©ä½ é€‰æ‹©ä¸²å£è®¾å¤‡ï¼Œè¿™æ˜¯æ­£å¸¸çš„æƒé™æœºåˆ¶ã€‚</span>
      <button id="btnClearLog">æ¸…ç©ºæ—¥å¿—</button>
    </div>
  </div>

<script>

(() => {
  // ====== å¸¸é‡ï¼šä¸åŸè„šæœ¬ä¸€è‡´ ======
  const BROADCAST_ID = 0xFE;   // 254
  const ADDR_ID      = 0x05;   // ID åœ°å€
  const ADDR_LOCK    = 0x37;   // é”åœ°å€
  const ADDR_TORQUE  = 0x28;   // æ‰­åŠ›å¼€å…³

  // çŠ¶æ€æŸ¥è¯¢é¦–åœ°å€ 0x38ï¼šä½ç½®/é€Ÿåº¦/è´Ÿè½½/ç”µå‹/æ¸©åº¦ï¼ˆå…±8å­—èŠ‚ï¼‰
  const ADDR_PRESENT = 0x38;
  const LEN_PRESENT  = 0x08;

  // ç›®æ ‡ä½ç½®é¦–åœ°å€ 0x2Aï¼šä½ç½®(2) + æ—¶é—´(2) + é€Ÿåº¦(2)
  const ADDR_GOAL    = 0x2A;

  // ====== çŠ¶æ€ ======
  let port = null;
  let writer = null;
  let reader = null;
  let readLoopRunning = false;
  let rxBuf = [];

  let pipelineRunning = false;
  let pipelineAbort = { abort: false };

  let scanRunning = false;
  let scanAbort = { abort: false };
  const scanMap = new Map();

  // ====== UI ======
  const logEl = document.getElementById('log');
  const statusPill = document.getElementById('statusPill');

  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const btnPingBroadcast = document.getElementById('btnPingBroadcast');
  const btnDoChange = document.getElementById('btnDoChange');
  const btnClearLog = document.getElementById('btnClearLog');

  const baudEl = document.getElementById('baud');
  const newIdEl = document.getElementById('newId');
  const confirmOneServoEl = document.getElementById('confirmOneServo');

  const pipeStartEl = document.getElementById('pipeStart');
  const pipeEndEl = document.getElementById('pipeEnd');
  const pipeConfirmOneEl = document.getElementById('pipeConfirmOne');
  const btnPipeStart = document.getElementById('btnPipeStart');
  const btnPipeStop = document.getElementById('btnPipeStop');
  const pipeStateEl = document.getElementById('pipeState');

  const scanStartEl = document.getElementById('scanStart');
  const scanEndEl = document.getElementById('scanEnd');
  const scanPeriodEl = document.getElementById('scanPeriod');
  const btnScanStart = document.getElementById('btnScanStart');
  const btnScanStop = document.getElementById('btnScanStop');
  const scanStateEl = document.getElementById('scanState');
  const posPeriodEl = document.getElementById('posPeriod');
  const btnPosStart = document.getElementById('btnPosStart');
  const btnPosStop = document.getElementById('btnPosStop');
  const posStateEl = document.getElementById('posState');
  const scanTableBody = document.getElementById('scanTableBody');

  const actIdEl = document.getElementById('actId');
  const actSpeedEl = document.getElementById('actSpeed');
  const actTimeEl = document.getElementById('actTime');
  const btnCenter = document.getElementById('btnCenter');
  const btnResetState = document.getElementById('btnResetState');

  function setStatus(text, kind="") {
    statusPill.textContent = text;
    statusPill.className = "pill " + kind;
  }

  function log(msg) {
    const t = new Date().toLocaleTimeString();
    logEl.textContent += `[${t}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  function u16le(lo, hi){ return (lo & 0xFF) | ((hi & 0xFF) << 8); }
  function toHex(b){ return `0x${(b & 0xFF).toString(16).padStart(2,'0')}`; }

  // ====== åè®®ï¼šæ ¡éªŒä¸ç»„åŒ…ï¼ˆchecksum = (~sum(data)) & 0xFFï¼‰======
  function calcChecksum(dataBytes) {
    let sum = 0;
    for (const b of dataBytes) sum += (b & 0xFF);
    return (~sum) & 0xFF;
  }
  function buildPacket(dataBytes) {
    const chk = calcChecksum(dataBytes);
    return new Uint8Array([0xFF, 0xFF, ...dataBytes, chk]);
  }

  async function ensureWriter() {
    if (!port) throw new Error("æœªè¿æ¥ä¸²å£");
    if (!writer) writer = port.writable.getWriter();
  }

  async function writeRaw(u8) {
    await ensureWriter();
    await writer.write(u8);
  }

  // ====== è¯»å–ï¼šç¼“å­˜æ”¶åˆ°çš„å­—èŠ‚ ======
  async function startReadLoop() {
    reader = port.readable.getReader();
    readLoopRunning = true;
    rxBuf = [];
    (async () => {
      try {
        while (readLoopRunning) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value && value.length) {
            for (const b of value) rxBuf.push(b);
            if (rxBuf.length > 8192) rxBuf = rxBuf.slice(-4096);
          }
        }
      } catch (e) {
        log(`è¯»å–å¼‚å¸¸: ${e.message || e}`);
      }
    })();
  }

  async function stopReadLoop() {
    readLoopRunning = false;
    if (reader) {
      try { await reader.cancel(); } catch {}
      try { reader.releaseLock(); } catch {}
      reader = null;
    }
    rxBuf = [];
  }

  // ====== å¸§è§£æï¼šä» rxBuf ä¸­æŠ½å–ä¸€å¸§ ======
  function tryPopFrameFromRxBuf() {
    // å¸§æ ¼å¼ï¼šFF FF ID LEN ERROR ... CHK
    // LEN = å‚æ•°ä¸ªæ•° + 2ï¼ˆERROR + CHKï¼‰
    for (let i = 0; i + 6 <= rxBuf.length; i++) {
      if (rxBuf[i] !== 0xFF || rxBuf[i+1] !== 0xFF) continue;
      const id = rxBuf[i+2];
      const len = rxBuf[i+3];
      const total = 2 + 1 + 1 + len; // FF FF + ID + LEN + (len bytes: ERROR..CHK)
      if (i + total > rxBuf.length) return null; // ä¸å¤Ÿé•¿
      const frame = rxBuf.slice(i, i + total);
      rxBuf = rxBuf.slice(i + total);
      return { id, len, frame };
    }
    return null;
  }

  async function waitFrame(filterFn, timeoutMs = 180) {
    const start = performance.now();
    while (performance.now() - start < timeoutMs) {
      const fr = tryPopFrameFromRxBuf();
      if (fr && (!filterFn || filterFn(fr))) return fr;
      await sleep(5);
    }
    return null;
  }

  // ====== å‘½ä»¤ï¼šping / read / write ======
  async function ping(targetId, timeoutMs = 150) {
    // FF FF ID 02 01 CHK
    const data = [targetId & 0xFF, 0x02, 0x01];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);

    // åªè¦æ”¶åˆ°ä»»æ„å›åŒ…ï¼ˆ>=6å­—èŠ‚ï¼‰å°±è®¤ä¸ºåœ¨çº¿
    const fr = await waitFrame(() => true, timeoutMs);
    return !!fr;
  }

  async function readData(targetId, address, length, timeoutMs = 220) {
    // FF FF ID 04 02 ADDR LEN CHK
    const data = [targetId & 0xFF, 0x04, 0x02, address & 0xFF, length & 0xFF];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);
    const fr = await waitFrame((f) => f.id === (targetId & 0xFF), timeoutMs);
    if (!fr) return null;

    // frame = [FF FF ID LEN ERROR ... CHK]
    const frame = fr.frame;
    const error = frame[4];
    const paramsLen = fr.len - 2; // å»æ‰ ERROR å’Œ CHK
    const params = frame.slice(5, 5 + paramsLen);

    // è½»é‡æ ¡éªŒï¼ˆå¯é€‰ï¼‰ï¼šæ ¡éªŒå’Œ = ~(ID + LEN + ERROR + PARAMS)
    const chk = frame[5 + paramsLen];
    const calc = calcChecksum([frame[2], frame[3], error, ...params]);
    if (chk !== calc) {
      // ä¸ç›´æ¥æŠ¥é”™ï¼Œé¿å…ä¸åŒå›ºä»¶å·®å¼‚å¯¼è‡´è¯¯åˆ¤
      log(`âš ï¸ æ ¡éªŒå’Œä¸ä¸€è‡´ï¼šrecv=${toHex(chk)} calc=${toHex(calc)}`);
    }

    return { id: fr.id, error, params };
  }

  async function writeReg(targetId, address, value) {
    // FF FF ID 04 03 ADDR VAL CHK
    const data = [targetId & 0xFF, 0x04, 0x03, address & 0xFF, value & 0xFF];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);
    await sleep(50);
  }

  async function writeBytes(targetId, address, bytes) {
    // WRITE DATA: LEN = N + 3ï¼ˆInstruction + Addr + N bytes + CHKï¼‰
    const n = bytes.length;
    const len = (n + 3) & 0xFF;
    const data = [targetId & 0xFF, len, 0x03, address & 0xFF, ...bytes.map(b => b & 0xFF)];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);
    await sleep(50);
  }

  async function resetState(targetId) {
    // RESET: LEN=0x02, INST=0x0A, no params
    const data = [targetId & 0xFF, 0x02, 0x0A];
    const pkt = buildPacket(data);
    rxBuf = [];
    await writeRaw(pkt);
    await sleep(80);
  }

  // ====== å•ç‹¬æ”¹å·ï¼šä¸¥æ ¼ä¿æŒåŸè„šæœ¬é¡ºåº ======
  async function changeId(newId) {
    newId = Number(newId);
    if (!(newId >= 1 && newId <= 253)) throw new Error("ID éœ€åœ¨ 1~253");

    log(`å¼€å§‹ï¼šç›®æ ‡æ–° ID = ${newId}`);

    log(`PING å¹¿æ’­(0xFE) ...`);
    const seen = await ping(BROADCAST_ID);
    log(seen ? "æ£€æµ‹åˆ°å›åŒ…ï¼ˆå¹¿æ’­ï¼‰" : "æœªæ£€æµ‹åˆ°å›åŒ…ï¼ˆæŸäº›è®¾å¤‡å¯èƒ½ä¸å›å¹¿æ’­ PINGï¼Œç»§ç»­å°è¯•å†™å…¥ï¼‰");

    log(`A) è§£é”ï¼šå†™ ${toHex(ADDR_LOCK)} = 0ï¼ˆå¹¿æ’­ï¼‰`);
    await writeReg(BROADCAST_ID, ADDR_LOCK, 0);

    log(`B) å…³æ‰­åŠ›ï¼šå†™ ${toHex(ADDR_TORQUE)} = 0ï¼ˆå¹¿æ’­ï¼‰`);
    await writeReg(BROADCAST_ID, ADDR_TORQUE, 0);

    log(`C) å†™IDï¼šå†™ ${toHex(ADDR_ID)} = ${newId}ï¼ˆå¹¿æ’­ï¼‰`);
    await writeReg(BROADCAST_ID, ADDR_ID, newId);
    await sleep(150);

    log(`D) ä¸Šé”ï¼šå†™ ${toHex(ADDR_LOCK)} = 1ï¼ˆID=${newId}ï¼‰`);
    await writeReg(newId, ADDR_LOCK, 1);

    log(`éªŒè¯ï¼šPING ID=${newId} ...`);
    let ok = await ping(newId, 180);
    if (!ok) {
      log("ç¬¬ä¸€æ¬¡éªŒè¯è¶…æ—¶ï¼Œ0.5s åé‡è¯•...");
      await sleep(500);
      ok = await ping(newId, 180);
    }

    if (ok) {
      log("âœ… ä¿®æ”¹æˆåŠŸï¼");
      setStatus(`å·²è¿æ¥ï¼ˆæœ€è¿‘æˆåŠŸæ”¹å·ï¼š${newId}ï¼‰`, "ok");
    } else {
      log("âŒ ä¿®æ”¹å¤±è´¥ï¼šè¯·æ£€æŸ¥å¤–æ¥ç”µæºã€çº¿åºï¼ˆTX/RX/GNDï¼‰ã€æ³¢ç‰¹ç‡æ˜¯å¦ä¸€è‡´ã€‚\nï¼ˆå¦‚æœæ€»çº¿ä¸Šä¸æ­¢ 1 ä¸ªèˆµæœºï¼Œä¹Ÿä¼šå¯¼è‡´å¼‚å¸¸ã€‚ï¼‰");
      throw new Error("éªŒè¯å¤±è´¥");
    }
  }

  // ====== æµæ°´çº¿ï¼šæŒç»­æ£€æµ‹æ’å…¥ -> å†™ID -> ç­‰å¾…æ‹”å‡º ======
  async function runPipeline(startId, endId, abortRef) {
    const s = Number(startId), e = Number(endId);
    if (!(s >= 0 && s <= 253 && e >= 0 && e <= 253 && s <= e)) throw new Error("èµ·å§‹/ç»“æŸ ID ä¸åˆæ³•");

    pipeStateEl.textContent = `è¿è¡Œä¸­ï¼šç­‰å¾…æ’å…¥ï¼ˆç›®æ ‡ ${s}..${e}ï¼‰`;
    log(`æµæ°´çº¿å¼€å§‹ï¼šèŒƒå›´ ${s}..${e}`);

    let targetId = s;

    // è¯´æ˜ï¼šç”¨å¹¿æ’­ PING ä½œä¸ºâ€œæ’å…¥æ£€æµ‹â€ã€‚è‹¥æ€»çº¿ä¸Šæœ‰å¤šä¸ªèˆµæœºä¼šåŒæ—¶åº”ç­”å¯¼è‡´å†²çªã€‚
    while (!abortRef.abort && targetId <= e) {
      pipeStateEl.textContent = `ç­‰å¾…æ’å…¥ï¼šç›®æ ‡ ID=${targetId}`;

      // 1) ç­‰å¾…æ’å…¥ï¼ˆå¹¿æ’­ ping æˆåŠŸï¼‰
      while (!abortRef.abort) {
        const ok = await ping(BROADCAST_ID, 180);
        if (ok) break;
        await sleep(80);
      }
      if (abortRef.abort) break;

      log(`>> æ£€æµ‹åˆ°èˆµæœºæ’å…¥ï¼Œå¼€å§‹å†™å…¥ ID=${targetId}`);

      try {
        // A è§£é”ï¼ˆå†™ 0 å…è®¸ä¿å­˜ï¼‰
        await writeReg(BROADCAST_ID, ADDR_LOCK, 0);
        // B å…³æ‰­åŠ›ï¼ˆå†™ 0ï¼‰
        await writeReg(BROADCAST_ID, ADDR_TORQUE, 0);
        // C å†™ IDï¼ˆåœ°å€ 0x05ï¼‰
        await writeReg(BROADCAST_ID, ADDR_ID, targetId);
        await sleep(160); // ç­‰å¾… EPROM å†™å…¥
        // D ä¸Šé”ï¼ˆå†™ 1ï¼‰
        await writeReg(targetId, ADDR_LOCK, 1);

        // E éªŒè¯
        const ok = await ping(targetId, 220);
        if (!ok) throw new Error("éªŒè¯å¤±è´¥ï¼šPING ä¸é€šï¼ˆè¯·ç¡®è®¤ä¾›ç”µ/åªæ¥ 1 ä¸ªèˆµæœºï¼‰");

        log(`âœ… å†™å…¥æˆåŠŸï¼šID=${targetId}`);
      } catch (err) {
        log(`âŒ å†™å…¥å¼‚å¸¸ï¼š${err?.message || err}`);
        // å†™å…¥å¤±è´¥åä¸è¦è‡ªåŠ¨æ¨è¿› IDï¼Œç­‰å¾…ç”¨æˆ·æ‹”æ’åé‡è¯•
      }

      // 2) ç­‰å¾…æ–­å¼€ï¼šå¯¹â€œç›®æ ‡IDâ€æŒç»­ ping ä¸é€š >= 1000ms æ‰è®¤ä¸ºæ‹”æ‰
      log("ç­‰å¾…æ‹”æ‰èˆµæœºâ€¦");
      let lostSince = null;
      while (!abortRef.abort) {
        const ok = await ping(targetId, 120);
        if (ok) {
          lostSince = null;
        } else {
          if (lostSince === null) lostSince = performance.now();
          if (performance.now() - lostSince >= 1000) break;
        }
        await sleep(80);
      }
      if (abortRef.abort) break;

      log("å·²æ£€æµ‹åˆ°æ–­å¼€ âœ‚ï¸");
      await sleep(150);

      targetId += 1;
    }

    const done = !abortRef.abort;
    pipeStateEl.textContent = done ? `å®Œæˆï¼šå·²é…ç½®è‡³ ${Math.min(e, targetId - 1)}` : "å·²ä¸­æ–­";
    log(done ? "ğŸ‰ æµæ°´çº¿å®Œæˆ" : "â¹ï¸ æµæ°´çº¿å·²ä¸­æ–­");
  }      if (abortRef.abort) break;

      log(`>> æ£€æµ‹åˆ°èˆµæœºæ’å…¥ï¼Œå¼€å§‹å†™å…¥ ID=${targetId}`);

      try {
        // A è§£é”
        await writeReg(BROADCAST_ID, ADDR_LOCK, 0);
        // B å…³æ‰­åŠ›
        await writeReg(BROADCAST_ID, ADDR_TORQUE, 0);
        // C å†™ID
        await writeReg(BROADCAST_ID, ADDR_ID, targetId);
        await sleep(150);
        // D ä¸Šé”
        await writeReg(targetId, ADDR_LOCK, 1);

        // éªŒè¯
        let ok = await ping(targetId, 220);
        if (!ok) {
          await sleep(500);
          ok = await ping(targetId, 220);
        }
        if (!ok) {
          log(`âŒ å†™å…¥åéªŒè¯å¤±è´¥ï¼ˆID=${targetId}ï¼‰ï¼Œè¯·æ£€æŸ¥ç”µæº/çº¿åº/æ˜¯å¦åŒæ—¶è¿æ¥å¤šèˆµæœº`);
          // å¤±è´¥æ—¶ï¼šè¦æ±‚æ‹”æ‰å†è¯•åŒä¸€ä¸ª ID
          pipeStateEl.textContent = `å¤±è´¥ï¼šè¯·æ‹”æ‰èˆµæœºåé‡è¯•ï¼ˆç›®æ ‡ ID=${targetId}ï¼‰`;
        } else {
          log(`âœ… å†™å…¥æˆåŠŸï¼šID=${targetId}`);
          targetId += 1;
        }
      } catch (e) {
        log(`æµæ°´çº¿å†™å…¥å¼‚å¸¸: ${e.message || e}`);
      }

      // 2) ç­‰å¾…æ‹”å‡ºï¼šè¿ç»­ 1s ping ä¸é€š
      pipeStateEl.textContent = `è¯·æ‹”æ‰èˆµæœº...ï¼ˆç»§ç»­ç›®æ ‡ ID=${targetId}ï¼‰`;
      let lostSince = null;
      while (!abortRef.abort) {
        // è¿™é‡Œç”¨å¹¿æ’­ ping æ¥åˆ¤å®šæ€»çº¿ä¸Šæ˜¯å¦è¿˜æœ‰èˆµæœº
        const ok = await ping(BROADCAST_ID, 180);
        if (ok) {
          lostSince = null;
        } else {
          if (lostSince === null) lostSince = performance.now();
          if (performance.now() - lostSince >= 1000) break;
        }
        await sleep(100);
      }
      if (abortRef.abort) break;

      log("å·²æ£€æµ‹åˆ°æ–­å¼€ âœ‚ï¸");
      await sleep(200);
    }

    const done = !abortRef.abort;
    pipeStateEl.textContent = done ? `å®Œæˆï¼šå·²é…ç½®åˆ° ${Math.min(endId, startId + (endId-startId))}` : "å·²ä¸­æ–­";
    log(done ? "ğŸ‰ æµæ°´çº¿å®Œæˆ" : "â¹ï¸ æµæ°´çº¿å·²ä¸­æ–­");
  }

  // ====== æ‰«æï¼šè½®è¯¢èŒƒå›´å†…åœ¨çº¿èˆµæœºå¹¶è¯»çŠ¶æ€ ======
  
  async function syncRead(address, length, ids, timeoutMs = 180) {
    // SYNC READ æŒ‡ä»¤ 0x82ï¼šFF FF FE (N+4) 82 addr len id... chk
    if (!ids || !ids.length) return new Map();
    const params = [address & 0xFF, length & 0xFF, ...ids.map(n => n & 0xFF)];
    const pkt = buildPacket(BROADCAST_ID, 0x82, params);
    await writeRaw(pkt);

    const out = new Map();
    for (const id of ids) {
      const frame = await waitFrame(id, timeoutMs);
      if (!frame) continue;
      // frame = [FF FF ID LEN ERROR ... CHK]
      const err = frame[4];
      if (err !== 0) continue;
      const data = frame.slice(5, 5 + length);
      out.set(id, data);
    }
    return out;
  }

  // ====== å®æ—¶ä½ç½®å¾ªç¯ï¼ˆä¸æ‰«æåˆ†å¼€ï¼‰ ======
  let posLoopRunning = false;
  let posAbort = { abort: false };

  async function runPosLoop(periodMs, abortRef) {
    const p = Math.max(20, Number(periodMs) || 50);
    posLoopRunning = true;
    posAbort = abortRef;
    while (!abortRef.abort) {
      const ids = Array.from(scanMap.keys()).sort((a,b)=>a-b);
      if (ids.length) {
        // ä¸€æ¬¡æ€§åŒæ­¥è¯» 0x38 èµ· 8 å­—èŠ‚ï¼šä½ç½®/é€Ÿåº¦/è´Ÿè½½/ç”µå‹/æ¸©åº¦
        const dataMap = await syncRead(ADDR_PRESENT, LEN_PRESENT, ids, 160);
        const now = Date.now();
        for (const [id, data] of dataMap.entries()) {
          const pos = u16le(data[0], data[1]);
          const spd = u16le(data[2], data[3]);
          const load = u16le(data[4], data[5]);
          const vol = data[6];
          const tmp = data[7];
          scanMap.set(id, { id, pos, speed: spd, load, voltage: vol, temp: tmp, ts: now });
        }
        renderScanTable();
      }
      await sleep(p);
    }
    posLoopRunning = false;
  }
function renderScanTable() {
    const rows = Array.from(scanMap.values()).sort((a,b)=>a.id-b.id);
    if (!rows.length) {
      scanTableBody.innerHTML = `<tr><td colspan="7" class="small">ï¼ˆæœªå‘ç°èˆµæœºï¼‰</td></tr>`;
      return;
    }
    scanTableBody.innerHTML = rows.map(r => {
      const t = new Date(r.ts).toLocaleTimeString();
      const v = (r.voltage != null) ? (r.voltage/10).toFixed(1) + 'V' : '-';
      const temp = (r.temp != null) ? r.temp + 'Â°C' : '-';
      return `<tr>
        <td>${r.id}</td>
        <td>${r.pos ?? '-'}</td>
        <td>${r.speed ?? '-'}</td>
        <td>${r.load ?? '-'}</td>
        <td>${v}</td>
        <td>${temp}</td>
        <td>${t}</td>
      </tr>`;
    }).join('');
  }

  async function scanOnce(startId, endId) {
    const s = Number(startId), e = Number(endId);
    if (!(s >= 0 && s <= 253 && e >= 0 && e <= 253 && s <= e)) throw new Error("æ‰«æèŒƒå›´ä¸åˆæ³•");

    // åªåšâ€œå‘ç°IDâ€ï¼Œä¸è¯»ä½ç½®ï¼ˆä½ç½®ç”±å®æ—¶ä½ç½®å¼€å…³æ¥è¯»ï¼‰
    const found = [];
    for (let id = s; id <= e; id++) {
      const ok = await ping(id, 60);
      if (ok) {
        found.push(id);
        if (!scanMap.has(id)) scanMap.set(id, { id, pos:null, speed:null, load:null, voltage:null, temp:null, ts: Date.now() });
      }
      // å°é—´éš”ï¼Œé¿å…æŒ¤çˆ†ä¸²å£
      await sleep(8);
    }

    scanStateEl.textContent = found.length ? `å·²å‘ç°ï¼š${found.join(", ")}` : "æœªå‘ç°èˆµæœº";
    renderScanTable();
  }
    const res = await readData(id, ADDR_PRESENT, LEN_PRESENT, 220);
    if (!res || !res.params || res.params.length < 8) {
      scanMap.set(id, { id, ts: Date.now() });
      return;
    }
    const p = res.params;
    const pos = u16le(p[0], p[1]);
    const speed = u16le(p[2], p[3]);
    const load = u16le(p[4], p[5]);
    const voltage = p[6];
    const temp = p[7];
    scanMap.set(id, { id, pos, speed, load, voltage, temp, ts: Date.now() });
  }

  async function runScan(startId, endId, periodMs, abortRef) {
    const p = Math.max(120, Number(periodMs) || 500);
    scanStateEl.textContent = "æ‰«æä¸­â€¦";
    while (!abortRef.abort) {
      await scanOnce(startId, endId);
      await sleep(p);
    }
    scanStateEl.textContent = "å·²åœæ­¢";
  }
      renderScanTable();
      const spent = performance.now() - t0;
      const wait = Math.max(0, period - spent);
      await sleep(wait);
    }

    scanStateEl.textContent = "æœªè¿è¡Œ";
    log("åœæ­¢æ‰«æ");
  }

  // ====== åŠ¨ä½œï¼šä¸­ä½ & RESET ======
  function toLE2(n){
    const v = Math.max(0, Math.min(65535, Number(n) || 0));
    return [v & 0xFF, (v >> 8) & 0xFF];
  }

  async function writeMiddleCalibrate(targetId) {
    const id = Number(targetId);
    if (!(id >= 0 && id <= 253)) throw new Error("ç›®æ ‡ ID ä¸åˆæ³•");
    // æŒ‰ä½ çš„éœ€æ±‚ï¼šå‘ 40 å·åœ°å€ï¼ˆADDR_TORQUE=0x28ï¼‰å†™å…¥ 128ï¼Œå°†å½“å‰ä½ç½®æ ¡æ­£ä¸º 2048
    await writeReg(id, ADDR_TORQUE, 128);
    log(`å·²å†™å…¥ï¼šID=${id} åœ°å€0x28(40) = 128`);
  }
  // ====== UI çŠ¶æ€ ======
  function setUiConnected(connected) {
    btnConnect.disabled = connected;
    btnDisconnect.disabled = !connected;

    btnPingBroadcast.disabled = !connected;
    btnDoChange.disabled = !connected;

    btnPipeStart.disabled = !connected;
    btnPipeStop.disabled = true;

    btnScanStart.disabled = !connected;
    btnScanStop.disabled = true;

    btnPosStart.disabled = !connected;
    btnPosStop.disabled = true;
    posStateEl.textContent = "å®æ—¶ä½ç½®ï¼šæœªè¿è¡Œ";

    btnCenter.disabled = !connected;
    btnResetState.disabled = !connected;

    baudEl.disabled = connected;

    if (!connected) setStatus("æœªè¿æ¥");
    else setStatus("å·²è¿æ¥", "ok");
  }

  function lockControlsBusy(busy) {
    // é¿å…å¹¶å‘æ“ä½œåŒä¸€ä¸²å£
    btnDoChange.disabled = busy || !port;
    btnPingBroadcast.disabled = busy || !port;
    btnPipeStart.disabled = busy || !port;
    btnScanStart.disabled = busy || !port;
    btnCenter.disabled = busy || !port;
    btnResetState.disabled = busy || !port;
  }

  // ====== äº‹ä»¶ ======
  btnClearLog.onclick = () => { logEl.textContent = ""; };

  btnConnect.onclick = async () => {
    try {
      if (!("serial" in navigator)) {
        alert("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Web Serialã€‚è¯·ä½¿ç”¨æ¡Œé¢ç‰ˆ Chrome/Edgeã€‚");
        return;
      }
      const baudRate = Number(baudEl.value || "1000000");
      if (!Number.isFinite(baudRate) || baudRate <= 0) {
        alert("æ³¢ç‰¹ç‡ä¸åˆæ³•");
        return;
      }

      port = await navigator.serial.requestPort();
      await port.open({ baudRate });
      await startReadLoop();

      setUiConnected(true);
      log(`å·²è¿æ¥ä¸²å£ï¼Œbaud=${baudRate}`);
    } catch (e) {
      log(`è¿æ¥å¤±è´¥: ${e.message || e}`);
      setUiConnected(false);
      port = null;
    }
  };

  btnDisconnect.onclick = async () => {
    try {
      // åœæ­¢åå°ä»»åŠ¡
      pipelineAbort.abort = true;
      scanAbort.abort = true;
      posAbort.abort = true;
      pipelineRunning = false;
      scanRunning = false;

      await stopReadLoop();
      if (writer) { try { writer.releaseLock(); } catch {} writer = null; }
      if (port) { await port.close(); }
      port = null;

      setUiConnected(false);
      log("å·²æ–­å¼€ä¸²å£");
    } catch (e) {
      log(`æ–­å¼€å¤±è´¥: ${e.message || e}`);
    }
  };

  btnPingBroadcast.onclick = async () => {
    try {
      lockControlsBusy(true);
      const ok = await ping(BROADCAST_ID);
      log(ok ? "å¹¿æ’­ PINGï¼šæ£€æµ‹åˆ°å›åŒ…" : "å¹¿æ’­ PINGï¼šæœªæ£€æµ‹åˆ°å›åŒ…");
    } catch (e) {
      log(`å¹¿æ’­ PING å¤±è´¥: ${e.message || e}`);
    } finally {
      lockControlsBusy(false);
    }
  };

  btnDoChange.onclick = async () => {
    try {
      if (!confirmOneServoEl.checked) {
        alert("è¯·å…ˆå‹¾é€‰â€œæˆ‘ç¡®è®¤ç›®å‰åªè¿æ¥äº† 1 ä¸ªèˆµæœºâ€ã€‚");
        return;
      }
      lockControlsBusy(true);
      await changeId(newIdEl.value);
    } catch (e) {
      // å·²åœ¨æ—¥å¿—æç¤º
    } finally {
      lockControlsBusy(false);
    }
  };

  // â€”â€” ä¸­å€¼æ ¡å‡†ï¼ˆå†™ 40 å·åœ°å€ = 128ï¼‰â€”â€”
  btnCenter.onclick = async () => {
    try {
      const id = Number(actIdEl.value);
      if (!Number.isFinite(id) || id < 0 || id > 253) throw new Error("ç›®æ ‡ ID ä¸åˆæ³•");
      lockControlsBusy(true);
      log(`å†™å…¥ä¸­å€¼æ ¡å‡†ï¼šID=${id}ï¼Œå†™ 0x28(40)=128`);
      await writeMiddleCalibrate(id);
      log("âœ… å·²å†™å…¥ä¸­å€¼æ ¡å‡†");
    } catch (e) {
      log(`ä¸­å€¼æ ¡å‡†å¤±è´¥: ${e.message || e}`);
    } finally {
      lockControlsBusy(false);
    }
  };

  // â€”â€” çŠ¶æ€é‡ç½®ï¼ˆRESET 0x0Aï¼‰â€”â€”
  btnResetState.onclick = async () => {
    try {
      const id = Number(actIdEl.value);
      if (!Number.isFinite(id) || id < 0 || id > 253) throw new Error("ç›®æ ‡ ID ä¸åˆæ³•");
      lockControlsBusy(true);
      log(`å‘é€ RESET(0x0A)ï¼ˆID=${id}ï¼‰`);
      await resetState(id);
      log("âœ… å·²å‘é€çŠ¶æ€é‡ç½®");
    } catch (e) {
      log(`çŠ¶æ€é‡ç½®å¤±è´¥: ${e.message || e}`);
    } finally {
      lockControlsBusy(false);
    }
  };

  btnPipeStart.onclick = async () => {
    try {
      if (!pipeConfirmOneEl.checked) {
        alert("æµæ°´çº¿æ¨¡å¼å¿…é¡»ç¡®ä¿ä»»ä½•æ—¶åˆ»æ€»çº¿ä¸Šåªæœ‰ 1 ä¸ªèˆµæœºï¼ˆæ’æ‹”é…ç½®ï¼‰ã€‚");
        return;
      }
      if (pipelineRunning || scanRunning) {
        alert("è¯·å…ˆåœæ­¢æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡ï¼ˆæµæ°´çº¿/æ‰«æï¼‰");
        return;
      }

      pipelineRunning = true;
      pipelineAbort = { abort: false };
      btnPipeStart.disabled = true;
      btnPipeStop.disabled = false;
      lockControlsBusy(true);

      await runPipeline(pipeStartEl.value, pipeEndEl.value, pipelineAbort);
    } catch (e) {
      log(`æµæ°´çº¿å¯åŠ¨å¤±è´¥: ${e.message || e}`);
    } finally {
      pipelineRunning = false;
      pipelineAbort.abort = true;
      btnPipeStart.disabled = !port;
      btnPipeStop.disabled = true;
      lockControlsBusy(false);
      pipeStateEl.textContent = "æœªè¿è¡Œ";
    }
  };

  btnPipeStop.onclick = async () => {
    pipelineAbort.abort = true;
    pipelineRunning = false;
    btnPipeStop.disabled = true;
    log("è¯·æ±‚ä¸­æ–­æµæ°´çº¿...");
  };

  btnScanStart.onclick = () => {
    if (scanRunning || pipelineRunning || posLoopRunning) {
      alert("è¯·å…ˆåœæ­¢æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡ï¼ˆæµæ°´çº¿/æ‰«æ/å®æ—¶ä½ç½®ï¼‰");
      return;
    }
    scanRunning = true;
    scanAbort = { abort: false };
    btnScanStart.disabled = true;
    btnScanStop.disabled = false;
    scanStateEl.textContent = "æ‰«æä¸­â€¦";

    runScan(scanStartEl.value, scanEndEl.value, scanPeriodEl.value, scanAbort)
      .catch(e => log(`æ‰«æå¼‚å¸¸: ${e.message || e}`))
      .finally(() => {
        scanRunning = false;
        btnScanStart.disabled = !port;
        btnScanStop.disabled = true;
      });
  };

  btnScanStop.onclick = () => {
    if (!scanRunning) return;
    scanAbort.abort = true;
    scanRunning = false;
    btnScanStart.disabled = !port;
    btnScanStop.disabled = true;
    scanStateEl.textContent = "å·²åœæ­¢";
  };

  btnPosStart.onclick = () => {
    if (posLoopRunning || pipelineRunning || scanRunning) {
      alert("è¯·å…ˆåœæ­¢æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡ï¼ˆæµæ°´çº¿/æ‰«æ/å®æ—¶ä½ç½®ï¼‰");
      return;
    }
    if (!scanMap.size) {
      alert("è¯·å…ˆæ‰«æä¸€æ¬¡ï¼Œæˆ–å…ˆå¯åŠ¨æ‰«æè®©å®ƒå‘ç°èˆµæœº IDã€‚");
      return;
    }
    posAbort = { abort: false };
    btnPosStart.disabled = true;
    btnPosStop.disabled = false;
    posStateEl.textContent = "å®æ—¶ä½ç½®ï¼šè¿è¡Œä¸­";
    runPosLoop(posPeriodEl.value, posAbort)
      .catch(e => log(`å®æ—¶ä½ç½®å¼‚å¸¸: ${e.message || e}`))
      .finally(() => {
        btnPosStart.disabled = !port;
        btnPosStop.disabled = true;
        posStateEl.textContent = "å®æ—¶ä½ç½®ï¼šå·²åœæ­¢";
      });
  };

  btnPosStop.onclick = () => {
    if (!posLoopRunning) return;
    posAbort.abort = true;
    btnPosStart.disabled = !port;
    btnPosStop.disabled = true;
    posStateEl.textContent = "å®æ—¶ä½ç½®ï¼šå·²åœæ­¢";
  };


</script>
</body>
</html>
